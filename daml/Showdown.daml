daml 1.2

module Showdown where

import Cards
import DA.List (head, tail)
import Chips
import Utils
import Hand

winning : [Card] -> [(Party, Card, Card)] -> [Party]
winning community hands = []

splitPot : Showdown -> Update [ContractId Chips]
splitPot showdown = do return []

template Showdown 
    with
        pot : Int
        dealer : Party
        remaining : [Party]
        shown : [(Party, Card, Card)]
        house : Party
        community : [Card]
        id : Int
    where
        signatory winning community shown, remaining, house

        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        controller head remaining can
            Reveal : Either [ContractId Chips] (ContractId Showdown)
                do
                    (handId, hand) <- fetchByKey @Hand (id, head remaining, dealer)
                    
                    let next = this with
                            shown = (head remaining, hand.card1, hand.card2) :: shown
                            remaining = tail remaining

                    if tail remaining == [] then                        
                        fmap Left $ splitPot next
                    else
                        fmap Right $ create next

            FoldHand : Either [ContractId Chips] (ContractId Showdown)
                do
                    if tail remaining == [] then
                        fmap Left $ splitPot this
                    else
                        fmap Right $ create this with remaining = tail remaining

-- import Game
-- import Scoring
-- import DA.Optional

-- data ShowdownNext =
--     Winners [ContractId Chips] | 
--     Next (ContractId Showdown)

-- splitPot : Int -> Int -> [Int]
-- splitPot = _

-- shareWinnings : Int -> [Party] -> Update [ContractId Chips]
-- shareWinnings pot winners house =
--     do
--         mapA (\(player, quantity) -> create Chips with house, player, quantity) $
--                 zip winners $ splitPot pot (length winners)

-- findWinners : [Card] -> [(Party, (Card, Card))] -> [Party]
-- findWinners _ [] = []
-- findWinners community hands = map (\(player, (hole1, hole2)) -> handRank hole1 :: hole2 :: community) 


-- shownHands : [(Party, Optional (Card, Card))] -> [(Party, (Card, Card))]
-- shownHands = catOptionals . map (\(player, hand) -> case hand of 
--                                                             Some h -> Some (player, h)
--                                                             None -> None)

-- next : Showdown -> Optional (Card, Card) -> Update ShowdownNext 
-- next showdown hand =
--     case showdown.unplayed of 
--         [last] ->
--             do
--                 let shownWinners = findWinners showdown.community
--                     $ shownHands $ showdown.hands :: (last, hand)

--                 let winners = if (winners == []) then [last] else shownWinners
 
--                 fmap Winners $ shareWinnings showdown.pot winners showdown.house

--         player :: unplayed ->
--             do
--                 fmap Next $ create showdown with unplayed
--                                 hands = (player, hand) :: showdown.hands

-- template Showdown
--     with
--         game : Game
--         unplayed : [Party]
--         hands : [(Party, Optional (Card, Card))]
--     where
--         signatory game.house, unplayed

--         controller head unplayed can
--             Fold : ShowdownStartNext
--                 do
--                     next this None

--             Show : ShowdownStartNext
--                 with
--                     cards : ContractId Hand
--                 do
--                     c <- fetch cards

--                     assert $ c.holder == head unplayed
--                     assert $ c.shuffle == game.shuffle

--                     next this (Some c.hand)
