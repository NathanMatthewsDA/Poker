daml 1.2

module SidePot where

import Cards
import DA.Optional
import DA.Foldable (maximum)
import Scoring
import DA.List
import DA.Tuple
import Seat

separate : (a -> Bool) -> [a] -> ([a], [a])
separate f xs = (filter f xs, filter (not . f) xs)

increaseSidePot : Int -> SidePot -> SidePot
increaseSidePot amount sidePot = sidePot with pot = sidePot.pot + amount

data SidePot = SidePot with
                score : Scored
                winners : [Party]
                bet : Int
                pot : Int
                  deriving (Show)

addFolded : [SidePot] -> Int -> [SidePot]
addFolded [] _ = error ""
addFolded [pot] folded = [increaseSidePot folded pot]
addFolded (pot :: pots) folded =
  if folded <= pot.pot then
    (increaseSidePot folded pot) :: pots
  else
    pot :: (addFolded pots folded)

generateSidePot : [(Party, Int, Scored)] -> SidePot
generateSidePot bets =
  SidePot with
    bet = snd3 $ head bets
    pot = sum $ map snd3 bets
    winners = map fst3 $ filter ((score ==) . thd3) bets
    score
  where
    score = maximum $ map thd3 bets

generateSidePots : [(Party, Int, Scored)] -> [SidePot]
generateSidePots scored =
    map generateSidePot $ groupOn snd3 $ sortOn snd3 scored

addSidePot : [SidePot] -> SidePot -> [SidePot]
addSidePot [] toAdd = [toAdd]
addSidePot (smallest :: higher) toAdd | toAdd.bet == smallest.bet =
  (winner with pot = smallest.pot + toAdd.pot) :: higher
  where
    winner = if smallest.score == toAdd.score then
               toAdd with winners = smallest.winners ++ toAdd.winners
             else if smallest.score > toAdd.score then
               smallest
             else 
               toAdd

addSidePot (smallest :: higher) toAdd | toAdd.bet < smallest.bet =
  if smallest.score >= toAdd.score then
    (increaseSidePot toAdd.pot smallest) :: higher
  else
    toAdd :: smallest :: higher

addSidePot (smallest :: higher) toAdd | toAdd.bet > smallest.bet =
  if toAdd.score >= smallest.score then
    addSidePot higher (increaseSidePot smallest.pot toAdd)
  else
    smallest :: (addSidePot higher toAdd)

split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

debug1 : [SidePot] -> [(Party, Int)]
debug1 pots = error $ show pots

calulateWinners : [Int] -> [(Party, Int, Scored)] -> [(Party, Int)]
calulateWinners folded =
    --debug1 . foldl addSidePot [] . (\pots -> foldl addFolded pots folded) . generateSidePots
    concatMap allocate . foldl addSidePot [] . (\pots -> foldl addFolded pots folded) . generateSidePots

scored : [Card] -> Seat -> Optional (Party, Int, Scored)
scored community seat = 
  fmap (\(card1, card2) -> 
          (seat.player, seat.bet, 
             handRank (card1 :: card2 :: community))) 
      seat.holeCards

findWinners : [Card] -> [Seat] -> [(Party, Int)]
findWinners community seats =
    case unfolded of
        [winner] ->
            [(winner.player, Seat.pot seats + winner.stack - winner.bet)]
        _ ->
            if any (\s -> s.holeCards == None) unfolded then
                []
            else
                calulateWinners
                    (map (.bet) folded)
                    $ mapOptional (scored community) unfolded
    where
        (folded, unfolded) = separate (.folded) seats
