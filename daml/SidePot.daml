daml 1.2

module SidePot where

import Cards
import DA.Optional
import Scoring
import Seat

separate : (a -> Bool) -> [a] -> ([a], [a])
separate f xs = (filter f xs, filter (not . f) xs)

increaseSidePot : Int -> SidePot -> SidePot
increaseSidePot amount sidePot = sidePot with pot = sidePot.pot + amount

data SidePot = SidePot with
                score : Scored
                winners : [Party]
                bet : Int
                pot : Int
                  deriving (Eq, Show)

fromSeat : [Card] -> Seat -> Optional SidePot
fromSeat community seat =
  fmap 
    (\(card1, card2) -> 
      SidePot with 
        score = 
          handRank (card1 :: card2 :: community)
        winners = [seat.player]
        bet = seat.bet
        pot = seat.bet)
    seat.holeCards

addFolded : [SidePot] -> Int -> [SidePot]
addFolded [] _ = error ""
addFolded [pot] folded = [increaseSidePot folded pot]
addFolded (pot :: pots) folded =
  if folded <= pot.pot then
    (increaseSidePot folded pot) :: pots
  else
    pot :: (addFolded pots folded)

addSidePot : [SidePot] -> SidePot -> [SidePot]
addSidePot [] toAdd = [toAdd]
addSidePot (smallest :: higher) toAdd | toAdd.bet == smallest.bet =
  (winner with pot = smallest.pot + toAdd.pot) :: higher
  where
    winner = if smallest.score == toAdd.score then
               toAdd with winners = smallest.winners ++ toAdd.winners
             else if smallest.score > toAdd.score then
               smallest
             else 
               toAdd

addSidePot (smallest :: higher) toAdd | toAdd.bet < smallest.bet =
  if smallest.score >= toAdd.score then
    (increaseSidePot toAdd.pot smallest) :: higher
  else
    toAdd :: smallest :: higher

addSidePot (smallest :: higher) toAdd | toAdd.bet > smallest.bet =
  if toAdd.score >= smallest.score then
    addSidePot higher (increaseSidePot smallest.pot toAdd)
  else
    smallest :: (addSidePot higher toAdd)

createSidePots : [Card] -> [Seat] -> [SidePot]
createSidePots community seats =
  (\pots -> foldl addFolded pots (map (.bet) folded)) $
  foldl addSidePot [] $
  mapOptional (fromSeat community) unfolded 
  where
    (folded, unfolded) = separate (.folded) seats

