daml 1.2

module Table where

import Cards
import Chips
import DA.Foldable (maximum)
import DA.Optional (isSome, fromSome, catOptionals)
import DA.List
import Utils
import Hand
import Scoring
import Seat
import Phase

playerTurn : Phase -> Party
playerTurn phase =
    case phase of   
        PlayerTurn (current,_) -> current
        _ -> error ""

applyActions : Party -> Phase -> [Seat] -> Update [Seat]
applyActions house phase seats = 
    case phase of
        Finished winners ->
            do
                mapA (\(owner, quantity) -> 
                        create Chips with owner,quantity, house, observers = [])
                    winners

                return seats

        PlayerTurn (_, ShowdownRound) ->
            do
                mapA (\s -> 
                        create Chips with 
                            owner = s.player
                            quantity = s.stack - s.bet
                            house
                            observers = [])
                    $ filter (\s -> s.stack > s.bet) $ seats
                
                return $ map (\s -> s with stack = s.bet) seats

        _ -> do return seats

next : Table -> Update (ContractId Table)
next table =
    case winners table.community table.seats of
        [] ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                create $ table with phase
        winners ->

            error "determine winners..."

-- nextAnyPlayer : Party -> Table -> Update (ContractId Table)
-- nextAnyPlayer player table = 
--     if inTurn player table.phase then
--         next table
--     else
--         create table

-- doFold : Party -> Table -> Update ()
-- doFold player table = 
--     do
--         assert $ elem player $ inGame table.seats
        
--         let r = remaining $ findSeat player table.seats

--         -- quantity <-
--             -- all other players have folded
--         if inGame table.seats == [player] then 
--             do
--                 let p = pot table.seats

--                 create table with 
--                     phase = Finished [(player, p)]
--                     seats = returnRemaining table.seats

--                 create Chips with 
--                     owner = player
--                     quantity = r + p
--                     house = table.house
--                     observers = []
--                 return ()
--         else do
--             nextAnyPlayer 
--                 player
--                 table with seats = fold player table.seats
            
--             if r > 0 then
--                 do
--                     create Chips with 
--                         owner = player
--                         quantity = r
--                         house = table.house
--                         observers = []
--                     return ()
--             else
--                 do
--                     return ()

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold = error "TODO"

returnRemaining : Party -> Party -> [Seat] -> Update (Optional (ContractId Chips))
returnRemaining house player seats =
    if seat.stack > seat.bet then
        do
            fmap Some $ create Chips with
                owner = player
                house
                quantity = seat.stack - seat.bet
                observers = []
    else
        do return None
    where
        seat = playerSeat player seats

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

template Table
    with        
        seats : [Seat]
        phase : Phase
        house : Party
        community : [Card]
        dealer : Party
        id : Int
    where
        signatory house, inGame seats
        observer map (.player) seats

        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                if nextShowdownTurn player phase then
                    next this with seats = reveal player cards seats
                else
                    create $ this with seats = reveal player cards seats

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                returnRemaining house player seats

                let table = this with seats = fold player seats

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        controller dealer can
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

        controller playerTurn phase can

            Check : ContractId Table
                do
                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ roundType phase == BettingRound

                    seats <- call (playerTurn phase) seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount (playerTurn phase) seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn (playerTurn phase) seats
