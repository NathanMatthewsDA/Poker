daml 1.2

module Table where

import Cards
import Chips
import Hand
import Seat
import Phase
import SidePot
import DA.List (delete, (!!), head)
import DA.Optional (fromSome)

turn : Party -> Phase -> Party
turn dealer phase =
    case phase of
        WaitingForPlayers _ -> dealer  
        PlayerTurn (current, _) -> current
        DealerTurn -> dealer
        Finished _ -> dealer

inShowdown : Phase -> Bool
inShowdown (PlayerTurn (_, ShowdownRound)) = True
inShowdown _ = False
    
split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

findWinners : [Card] -> [Seat] -> Optional EndGame
findWinners community seats =
    case unfolded of
        [winner] ->
            Some $ OneRemaining (winner.player, Seat.pot seats + winner.stack - winner.bet)
        _ ->
            if any (\s -> s.holeCards == None) unfolded then
                None
            else
                Some $ ShowdownWinners (createSidePots community seats)
    where
        (folded, unfolded) = separate (.folded) seats

payout : ContractId Chips -> [(Party, Int)] -> Update (ContractId Chips)
payout pot [] = return pot
payout pot ((taker, amount) :: []) =
    do exercise pot TakeOwnership with owner = taker

payout pot ((taker, amount) :: remaining) =
    do
        (winnings, pot) <- exercise pot Split with amount
        exercise winnings TakeOwnership with owner = taker
        pot <- exercise pot Leave with leaver = taker
        payout pot remaining

finish : EndGame -> Table -> Update (ContractId Table)
finish game table = 
    do 
        case game of
            ShowdownWinners winners ->            
                payout table.pot $ concatMap allocate winners
            OneRemaining (taker, amount) -> 
                return $ table.pot
        
        create $ table with phase = Finished $ game

next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        Some game ->
            finish game table
--            create table with phase = Finished game
        None ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                if inShowdown phase then
                    do
                        pot <- payout table.pot $
                            map (\s -> (s.player, s.stack - s.bet)) $
                            table.seats

                        let seats = map (\s -> s with stack = s.bet) table.seats
                        create $ table with phase, seats, pot
                else
                    do create table with phase

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold table =
    case findWinners table.community table.seats of
        Some game -> finish game table
        None -> create table

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

signatories : Table -> [Party]
signatories table = 
    case table.phase of
        Finished _ -> []
        _ -> inGame table.seats

-- createTable : ContractId Chips -> Party -> Int -> Int -> Update (ContractId Table)
-- createTable pot dealer id smallBlind =
--     create Table with
--         seats = []
--         phase = WaitingForPlayers
--         community = []
--         dealer
--         id
--         smallBlind
--         pot
--         observers = []

template TableInvitation
    with
        dealer : Party
        id : Int
        player : Party
    where
        signatory dealer

        controller player can
            AcceptTableInvitation : ContractId Table
                with
                    stack : ContractId Chips
                    seed : ContractId PlayerSeed
                do
                    exerciseByKey @Table (id, dealer) JoinTable with player, stack, seed

assertWaitingForPlayers : Phase -> Update ()
assertWaitingForPlayers phase = 
    case phase of
        WaitingForPlayers _ -> return ()
        _ -> error ""

template Table
    with
        pot : ContractId Chips
        seats : [Seat]
        phase : Phase
        community : [Card]
        dealer : Party
        id : Int
        observers : [Party]
        smallBlind : Int
    where
        signatory dealer, signatories this

        observer observers

        key (id, dealer) : (Int, Party)

        maintainer key._2

        choice JoinTable : ContractId Table
            with 
                player : Party
                seed : ContractId PlayerSeed
                stack : ContractId Chips
            controller player, dealer
            do
                case phase of 
                    WaitingForPlayers pending ->
                        do
                            assert $ not $ elem player pending

                            chips <- fetch stack

                            pot <- exercise pot AddOwner with owner = player
                            pot <- exercise pot AddChips with chips = stack, chipsOwners = [player]
            
                            let seat = Seat with
                                                stack = chips.quantity
                                                seed
                                                player
                                                bet = 0
                                                folded = False
                                                holeCards = None
                                                
                            create this with
                                seats = seats ++ [seat]
                                pot
                                phase = WaitingForPlayers (player :: pending)

                    _ -> error $ "Player: " <> show player <> " cannot join table as it has already started"
                
        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                let table = this with seats = reveal player cards seats

                if nextShowdownTurn player phase then
                    next table
                else
                    create table

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                let seat = playerSeat player seats 

                (unbet, pot) <- exercise pot Split with amount = seat.stack - seat.bet

                pot <- exercise pot Leave with leaver = player
                exercise unbet TakeOwnership with owner = player 

                let table = this with seats = fold player seats, pot

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        choice InvitePlayer : ContractId TableInvitation
            with
                player : Party
                inviter : Party
            controller inviter
            do
                assert $ elem inviter $ map (.player) seats
                assert $ not $ elem player $ map (.player) seats
                assertWaitingForPlayers phase
            
                potSize <- fmap (.quantity) $ fetch pot

                pot <- exercise pot AddObserver with adder = inviter, obs = player

                create this with 
                    observers = player :: observers
                    pot
                    seats = case seats of
                                [seat] -> [seat with stack = potSize]
                                s -> s

                create TableInvitation with dealer, player, id

        choice PlayerReady : ContractId Table
            with
                player : Party
            controller player
            do            
                case phase of
                    WaitingForPlayers waitingFor ->
                        do
                            assert $ elem player waitingFor

                            create this with phase = WaitingForPlayers (delete player waitingFor)

                    _ -> error "Illegal state"

        controller dealer can 
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

            StartHand : ContractId Table
                do
                    assertWaitingForPlayers phase
                    assert $ length seats > 2

                    table <- create this with phase = PlayerTurn ((head seats).player, BettingRound)
                    table <- exercise table Raise with amount = smallBlind
                    table <- exercise table Raise with amount = smallBlind * 2

                    return table

        controller turn dealer phase can
            Check : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ phase /= DealerTurn

                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    seats <- call player seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount player seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn player seats
