daml 1.2

module Table where

import Cards
import Chips
import DA.Optional (fromSome, mapOptional)
import DA.Foldable (maximum)
import DA.List (head, delete, dedup)
import SidePot (createSidePots1, SidePot, allocate)
import Utils
import Seat

template CommunityCard
    with
        dealer : Party
        card : Card
    where
        signatory dealer

template Table
    with
        pot : Optional (ContractId Pot)
        seats : [Seat]
        unturned : [ContractId CommunityCard]
        community : [Card]
        dealer : Party
        tableStake : Int
        observers : [Party]
        smallBlind : Int
    where
        signatory activePlayers seats

bet : Table -> Party -> Int -> Update Table
bet table player amount =
    case seat.stack of
        InPlay stack ->
            if required == 0 && amount == 0 then
                return table
            else do                
                avaliable <- fmap (.quantity) $ fetch stack

                (forPot, stack) <-
                    if amount == avaliable then
                        return (stack, ChipsAllIn)
                    else if avaliable < required then
                        error ("Player: " <> show player <> " can't place bet as their stack: "
                                <> show avaliable <> " isn't enough for required bet: " <> show required <>
                                ", they must either fold or go all-in with bet of: " <> show avaliable) 
                    else if amount < required then
                        error ("Player: " <> show player <> " can't place bet of: " 
                                <> show amount <> " as its less than the required amount of: "
                                <> show required)
                    else 
                        do
                            (forPot, remaining) <- exercise stack Split with amount
                            return (forPot, InPlay remaining)                
                    -- else 
                    --     error ("Player: " <> show player <> " doesn't have enough in stack: "
                    --             <> show avaliable <> " to meet required: " <> show required <>
                    --             ", either fold or go all-in with bet of: " <> show avaliable) 
                    
                let newSeat = seat with stack, stake = seat.stake + amount

                pot <- case table.pot of
                          Some pot ->                            
                            exercise pot AddChips with chips = forPot, owner = player
                          None ->
                            exercise forPot CreatePot


                return $ table with
                            seats = replace seat newSeat table.seats 
                            pot = Some pot
        ChipsAllIn -> 
            error ("Player: " <> show player <> " cannot bet as they have an emoty stack")

        Folded _ ->
            error ("Player: " <> show player <> " cannot bet as they have folded")
    where
        seat = findSeat player table.seats
        required = maximum (map (.stake) table.seats) - seat.stake

fold : Table -> Party -> Update Table
fold table player =
    case seat.stack of
        InPlay stack ->
            do
                pot <- exercise (fromSome table.pot) Leave with owner = player

                let newSeat = seat with stack = Folded stack
                return $ table with
                    seats = replace seat newSeat table.seats
                    pot = Some pot
        ChipsAllIn ->
            error ("Player: " <> show player <> " cannot fold as they are already all-in")
        Folded _ ->
            error ("Player: " <> show player <> " cannot fold as they are already folded")
    where
        seat = findSeat player table.seats

reveal : Table -> Party -> Update Table
reveal table player =
    do
        case seat.hand of
            Hidden handId -> 
                do
                    hand <- fetch handId

                    assert $ hand.dealer == table.dealer

                    let newSeat = seat with hand = Revealed (hand.card1, hand.card2)

                    return $ table with seats = replace seat newSeat table.seats
            Revealed _ -> error "Hand is already revealed"

            _ -> error "Illegal state exception"
    where
        seat = findSeat player table.seats

isShowdownTime : [Seat] -> Bool
isShowdownTime seats = length (filterInPlay seats) <= 1

showCommunity : Table -> Update Table
showCommunity table =
    do
        assert $ table.unturned /= []

        (t, u) <- 
            if isShowdownTime table.seats then
                do  
                    cards <- mapA (fmap (.card) . fetch) table.unturned               
                    return $ (cards, [])                                        
            else if length table.community == 0 then
                do
                    cards <- mapA (fmap (.card) . fetch) $ take 3 table.unturned
                    return $ (cards, drop 3 table.unturned)
            else
                do
                    let toTurn :: unturned = table.unturned
                    card <- fmap (.card) $ fetch $ toTurn
                    return $ ([card], unturned)

        return $ table with community = table.community ++ t, unturned = u


-- payout : ContractId Chips -> [(Party, Int)] -> Update (ContractId Chips)
-- payout pot [] = return pot
-- payout pot ((taker, amount) :: []) =
--     do exercise pot TakeOwnership with owner = taker

-- payout pot ((taker, amount) :: remaining) =
--     do
--         (winnings, pot) <- exercise pot Split with amount
--         exercise winnings TakeOwnership with owner = taker
--         pot <- exercise pot Leave with leaver = taker
--         payout pot remaining

finish : Table -> Update (Table, [SidePot])
finish table = 
    do
        (winnings) <- splitPot shares (fromSome table.pot)

        seats <- mapA (mergeWinnings winnings) table.seats

        let newTable = table with
                        pot = None
                        seats = rotate (map resetSeat seats)
                        unturned = []
                        community = []
        return $ (newTable,  sidePots)
    where 
        sidePots = toSidePots table.community table.seats
        shares = concatMap allocate sidePots

addObserver : Party -> Table -> Update Table
addObserver player table = 
    do
        seats <- mapA (\seat -> do 
                                    stack <- addStackObserver seat.stack player
                                    return seat with stack)
                    table.seats
        -- pot <- exercise table.pot AddPotObserver with player

        return $ table with seats, observers = dedup $ player :: table.observers

