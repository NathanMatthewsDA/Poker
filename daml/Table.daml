daml 1.2

module Table where

import Cards
import Chips
import Hand
import Seat
import Phase
import SidePot
import DA.List (delete, (!!), head)
import DA.Optional (fromSome)

turn : Party -> Phase -> Party
turn dealer phase =
    case phase of
        WaitingForPlayers -> dealer  
        PlayerTurn (current, _) -> current
        DealerTurn -> dealer
        Finished _ -> dealer

inShowdown : Phase -> Bool
inShowdown (PlayerTurn (_, ShowdownRound)) = True
inShowdown _ = False
    
split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

findWinners : [Card] -> [Seat] -> Optional EndGame
findWinners community seats =
    case unfolded of
        [winner] ->
            Some $ OneRemaining (winner.player, Seat.pot seats + winner.stack - winner.bet)
        _ ->
            if any (\s -> s.holeCards == None) unfolded then
                None
            else
                Some $ ShowdownWinners (createSidePots community seats)
    where
        (folded, unfolded) = separate (.folded) seats

payout : ContractId Chips -> [(Party, Int)] -> Update (ContractId Chips)
payout pot [] = return pot
payout pot ((taker, amount) :: remaining) =
    do
        pot <- exercise pot Take with taker, amount
        payout pot remaining

finish : EndGame -> Table -> Update (ContractId Table)
finish game table = 
    do 
        pot <- case game of
                ShowdownWinners winners ->
                    payout table.pot $ concatMap allocate winners
                OneRemaining (taker, amount) ->
                    exercise table.pot Take with taker, amount
        
        create $ table with phase = Finished $ game, pot

next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        Some game ->
            finish game table
--            create table with phase = Finished game
        None ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                if inShowdown phase then
                    do
                        pot <- payout table.pot $
                            map (\s -> (s.player, s.stack - s.bet)) $
                            table.seats

                        let seats = map (\s -> s with stack = s.bet) table.seats
                        create $ table with phase, seats, pot
                else
                    do create table with phase

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold table =
    case findWinners table.community table.seats of
        Some game -> finish game table
        None -> create table

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

signatories : Table -> [Party]
signatories table = 
    case table.phase of
        Finished _ -> []
        _ -> inGame table.seats

createTable : ContractId Chips -> Party -> Int -> Int -> Update (ContractId Table)
createTable pot dealer id smallBlind =
    create Table with
        seats = []
        phase = WaitingForPlayers
        community = []
        dealer
        id
        smallBlind
        pot
        observers = []

template TableInvitation
    with
        dealer : Party
        id : Int
        player : Party
    where
        signatory dealer

        controller player can
            AcceptTableInvitation : ContractId Table
                with
                    stack : ContractId Chips
                do
                    exerciseByKey @Table (id, dealer) JoinTable with player, stack

template Table
    with
        pot : ContractId Chips
        seats : [Seat]
        phase : Phase
        community : [Card]
        dealer : Party
        id : Int
        observers : [Party]
        smallBlind : Int
    where
        signatory dealer, signatories this

        observer observers

        key (id, dealer) : (Int, Party)

        maintainer key._2

        choice JoinTable : ContractId Table
            with 
                player : Party
                stack : ContractId Chips
            controller player, dealer
            do
                assert $ phase == WaitingForPlayers

                chips <- fetch stack
                -- exercise stack Archive

                pot <- exercise pot Merge with other = player, chips = stack
 
                let seat = Seat with
                                    stack = chips.quantity
                                    player
                                    bet = 0
                                    folded = False
                                    holeCards = None
                                    
                create this with seats = seats ++ [seat], pot
                
        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                let table = this with seats = reveal player cards seats

                if nextShowdownTurn player phase then
                    next table
                else
                    create table

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                let seat = playerSeat player seats 

                pot <- exercise pot LeaveWith with 
                            leaver = player
                            amount = seat.stack - seat.bet

                let table = this with seats = fold player seats, pot

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        controller dealer can 
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

            InvitePlayer : ContractId TableInvitation
                with
                    player : Party
                do
                    assert $ not $ elem player $ map (.player) seats
                    assert $ phase == WaitingForPlayers

                    pot <- exercise pot AddObserver with adder = dealer, obs = player

                    create this 
                        with 
                            observers = player :: observers
                            pot

                    create TableInvitation with dealer, player, id

            StartHand : ContractId Table
                do
                    assert $ phase == WaitingForPlayers            
                    assert $ length seats > 2

                    table <- create this with phase = PlayerTurn ((head seats).player, BettingRound)
                    table <- exercise table Raise with amount = smallBlind
                    table <- exercise table Raise with amount = smallBlind * 2

                    return table

        controller turn dealer phase can
            Check : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ phase /= DealerTurn

                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    seats <- call player seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount player seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn player seats
