daml 1.2

module Table where

import Cards
import Chips
import Hand
import Seat
import Phase
import SidePot

turn : Party -> Phase -> Party
turn dealer phase =
    case phase of   
        PlayerTurn (current, _) -> current
        DealerTurn -> dealer
        Finished _ -> dealer

inShowdown : Phase -> Bool
inShowdown (PlayerTurn (_, ShowdownRound)) = True
inShowdown _ = False
    
split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

findWinners : [Card] -> [Seat] -> Optional EndGame
findWinners community seats =
    case unfolded of
        [winner] ->
            Some $ OneRemaining (winner.player, Seat.pot seats + winner.stack - winner.bet)
        _ ->
            if any (\s -> s.holeCards == None) unfolded then
                None
            else
                Some $ ShowdownWinners (createSidePots community seats)
    where
        (folded, unfolded) = separate (.folded) seats

finish : [SidePot] -> Table -> Update (ContractId Table)
finish winners table = 
    do
        mapA (\(owner, quantity) -> 
                create Chips with 
                    owner
                    quantity
                    house = table.house
                    observers = [])
            $ concatMap allocate winners

        create $ table with 
            phase = Finished $ ShowdownWinners winners

next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        Some game ->
            create table with phase = Finished game
        None ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                seats <- if inShowdown phase then
                            returnAllRemaining table.house table.seats                        
                         else
                            do return $ table.seats

                create $ table with phase, seats

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold table =
    case findWinners table.community table.seats of
        Some game ->
            create table with phase = Finished game 
        None ->
            create table

returnAllRemaining : Party -> [Seat] -> Update [Seat]
returnAllRemaining house seats =
    mapA (returnRemaining house) seats
 
returnRemaining : Party -> Seat -> Update Seat
returnRemaining house seat =
    if seat.stack > seat.bet then
        do
            create Chips with
                owner = seat.player
                house
                quantity = seat.stack - seat.bet
                observers = []

            return $ seat with stack = seat.bet
    else
        do return seat

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

signatories : Table -> [Party]
signatories table = 
    case table.phase of
        Finished _ -> [table.house]
        _ -> table.house :: inGame table.seats

template Table
    with        
        seats : [Seat]
        phase : Phase
        house : Party
        community : [Card]
        dealer : Party
        id : Int
    where
        signatory signatories this

        observer map (.player) seats

        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                let table = this with seats = reveal player cards seats

                if nextShowdownTurn player phase then
                    next table
                else
                    create table

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                returnRemaining house $ playerSeat player seats

                let table = this with seats = fold player seats

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        controller turn dealer phase can
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

            Check : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ phase /= DealerTurn

                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    seats <- call player seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount player seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn player seats
