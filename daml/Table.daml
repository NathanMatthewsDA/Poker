daml 1.2

module Table where

import Cards
import Chips
import DA.Foldable (maximum)
import DA.Optional (isSome, fromSome, catOptionals)
import DA.List
import Utils
import Hand
import Scoring
import Seat
import Phase
import SidePot

playerTurn : Phase -> Party
playerTurn phase =
    case phase of   
        PlayerTurn (current, _) -> current
        _ -> error ""

inShowdown : Phase -> Bool
inShowdown (PlayerTurn (_, ShowdownRound)) = True
inShowdown _ = False
    
next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        [] ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                seats <- if inShowdown phase then
                            do returnAllRemaining table.house table.seats
                         else
                            do return $ table.seats

                create $ table with phase, seats
        winners ->
            do
                mapA (\(owner, quantity) -> 
                        create Chips with 
                            owner
                            quantity
                            house = table.house
                            observers = [])
                    winners

                create $ table with phase = Finished winners

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold = error ""

returnAllRemaining : Party -> [Seat] -> Update [Seat]
returnAllRemaining house seats =
    do
        mapA (returnRemaining house) seats

        return $ map (\s -> s with stack = s.bet) seats

returnRemaining : Party -> Seat -> Update (Optional (ContractId Chips))
returnRemaining house seat =
    if seat.stack > seat.bet then
        do
            fmap Some $ create Chips with
                owner = seat.player
                house
                quantity = seat.stack - seat.bet
                observers = []
    else
        do return None

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

template Table
    with        
        seats : [Seat]
        phase : Phase
        house : Party
        community : [Card]
        dealer : Party
        id : Int
    where
        signatory house, inGame seats
        observer map (.player) seats

        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                if nextShowdownTurn player phase then
                    next this with seats = reveal player cards seats
                else
                    create $ this with seats = reveal player cards seats

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                returnRemaining house $ playerSeat player seats

                let table = this with seats = fold player seats

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        controller dealer can
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

        controller playerTurn phase can

            Check : ContractId Table
                do
                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ roundType phase == BettingRound

                    seats <- call (playerTurn phase) seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount (playerTurn phase) seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn (playerTurn phase) seats
