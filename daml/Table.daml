daml 1.2

module Table where

import Cards
import Chips
import Seat
import Phase
import SidePot
import DA.List (delete, (!!), head, dedup)
import DA.Optional (fromSome)
import DA.Action (foldlA)

turn : Party -> Phase -> Party
turn dealer phase =
    case phase of
        WaitingForPlayers _ _ -> dealer
        InGame (PlayerTurn (current, _)) -> current
        InGame (DealerTurn) -> dealer
        Finished _ -> dealer

inShowdown : Phase -> Bool
inShowdown (InGame (PlayerTurn (_, ShowdownRound))) = True
inShowdown _ = False
    
split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

findWinners : [Card] -> [Seat] -> Optional EndGame
findWinners community seats =
    case unfolded of
        [winner] ->
            Some $ OneRemaining (winner.player, Seat.pot seats + winner.stack - winner.bet)
        _ ->
            if all (revealed . (.revealed)) unfolded then
                Some $ ShowdownWinners (createSidePots community seats)
            else
                None                
    where
        (folded, unfolded) = separate (.folded) seats
        revealed r = case r of 
                        HoleCards _ -> True 
                        _ -> False

payout : ContractId Chips -> [(Party, Int)] -> Update (ContractId Chips)
payout pot [] = return pot
payout pot ((taker, amount) :: []) =
    do exercise pot TakeOwnership with owner = taker

payout pot ((taker, amount) :: remaining) =
    do
        (winnings, pot) <- exercise pot Split with amount
        exercise winnings TakeOwnership with owner = taker
        pot <- exercise pot Leave with leaver = taker
        payout pot remaining

finish : EndGame -> Table -> Update (ContractId Table)
finish game table = 
    do 
        case game of
            ShowdownWinners winners ->            
                payout table.pot $ concatMap allocate winners
            OneRemaining (taker, amount) -> 
                return $ table.pot
        
        create $ table with phase = Finished $ game

returnUnbet : ContractId Chips -> Seat -> Update (ContractId Chips)
returnUnbet pot seat =
    if not seat.folded && seat.stack > seat.bet then
      do
        (unbet, pot) <- exercise pot Split with amount = seat.stack - seat.bet
        exercise unbet TakeOwnership with owner = seat.player
        return pot
    else
        do return pot

next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        Some game ->
            finish game table
--            create table with phase = Finished game
        None ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                if inShowdown phase then
                    do
                        pot <- foldlA returnUnbet table.pot table.seats
                        let seats = map (\s -> s with stack = s.bet) table.seats
                        create $ table with phase, seats, pot
                else
                    do create table with phase

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (InGame (PlayerTurn (turn, ShowdownRound))) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (InGame (PlayerTurn (turn, _))) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold table =
    case findWinners table.community table.seats of
        Some game -> finish game table
        None -> create table

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

assertWaitingForPlayers : Phase -> Update ()
assertWaitingForPlayers phase = 
    case phase of
        WaitingForPlayers _ _ -> return ()
        _ -> error ""

tableObservers : Phase -> [Party]
tableObservers (WaitingForPlayers {pendingJoin}) = pendingJoin
tableObservers _ = []

createTable : Party -> ContractId Chips -> Int -> Int -> Update (ContractId Table)
createTable dealer stack seed smallBlind = 
    do
        c <- fetch stack
        assert $ length c.owners == 1
        let player = head c.owners
        
        seed <- create PlayerSeed with player, seed, dealer

        create Table with
            pot = stack            
            seats = [Seat with 
                        seed
                        folded = False
                        revealed = NotDealt
                        player
                        bet = 0
                        stack = c.quantity]

            phase = WaitingForPlayers {pendingJoin = [], pendingReady = [player]}
            community = []
            dealer
            observers = []
            smallBlind

template Table
    with
        pot : ContractId Chips
        seats : [Seat]
        phase : Phase
        community : [Card]
        dealer : Party
        observers : [Party]
        smallBlind : Int
    where
        signatory map (.player) seats

        observer observers, map (.player) seats, tableObservers phase

        -- choice JoinTable : ContractId Table
        --     with
        --         player : Party
        --     controller player
        --     do            
        --         case phase of 
        --             WaitingForPlayers {pendingReady, pendingJoin} ->
        --                 do                            
        --                     assert $ elem player pendingJoin
        --                     assert $ not $ elem player pendingReady

        --                     chips <- fetch stack

        --                     pot <- exercise pot AddOwner with owner = player
        --                     pot <- exercise pot AddChips with chips = stack, chipsOwners = [player]
            
        --                     let seat = Seat with
        --                                         stack = chips.quantity
        --                                         seed
        --                                         player
        --                                         bet = 0
        --                                         folded = False
        --                                         revealed = NotDealt
                                                
        --                     create this with
        --                         seats = seats ++ [seat]
        --                         pot
        --                         phase = WaitingForPlayers with
        --                                     pendingReady = player :: pendingReady
        --                                     pendingJoin = delete player pendingJoin

        --             _ -> error $ "Player: " <> show player <> " cannot join table as it has already started"
                
        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                -- error $ show $ signatories this
                assert $ elem player $ map (.player) seats

                let seat = findSeat player seats

                case seat.revealed of
                    NotDealt -> error "Hole cards have't been dealt"
                    HoleCards _ -> create this
                    HiddenHand handId ->
                        do
                            hand <- fetch handId

                            assert $ hand.dealer == dealer

                            let cards = (hand.card1, hand.card2)

                            let table = this with seats = reveal player cards seats

                            if nextShowdownTurn player phase then
                                next table
                            else
                                create table

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                let seat = playerSeat player seats 

                (unbet, pot) <- exercise pot Split with amount = seat.stack - seat.bet

                pot <- exercise pot Leave with leaver = player
                exercise unbet TakeOwnership with owner = player 

                let table = this with seats = fold player seats, pot

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        choice InvitePlayer : ContractId Table
            with
                player : Party
                inviter : Party
            controller inviter
            do
                assertMsg ("Inviter: " <> show inviter <> " is not currently a member of table, current members: " <> (show $ map (.player) seats))
                    $ elem inviter $ map (.player) seats

                assert $ not $ elem player $ map (.player) seats
                
                case phase of 
                    WaitingForPlayers {pendingReady, pendingJoin} ->
                        do
                            potSize <- fmap (.quantity) $ fetch pot

                            pot <- exercise pot AddObserver with adder = inviter, obs = player

                            create this with 
                                phase = WaitingForPlayers {pendingReady, pendingJoin = dedup (player :: pendingJoin)}
                                pot

                    _ -> error "Can only invite players before round has started"

        choice PlayerReady : ContractId Table
            with
                player : Party
            controller player
            do      
                case phase of
                    WaitingForPlayers {pendingReady, pendingJoin} ->
                        do
                            assert $ elem player pendingReady

                            create this with phase = WaitingForPlayers with
                                                        pendingReady = delete player pendingReady
                                                        pendingJoin

                    _ -> error "Illegal state"
      

        choice JoinTable : ContractId Table
            with
                player : Party
                seed : ContractId PlayerSeed
                stack : ContractId Chips 
            controller player
            do            
                case phase of 
                    WaitingForPlayers {pendingReady, pendingJoin} ->
                        do                            
                            assert $ elem player pendingJoin
                            assert $ not $ elem player pendingReady

                            chips <- fetch stack

                            pot <- exercise pot AddOwner with owner = player
                            pot <- exercise pot AddChips with chips = stack, chipsOwners = [player]
            
                            let seat = Seat with
                                                stack = chips.quantity
                                                seed
                                                player
                                                bet = 0
                                                folded = False
                                                revealed = NotDealt

                            create this with
                                seats = seats ++ [seat]
                                pot
                                phase = WaitingForPlayers with
                                            pendingReady = player :: pendingReady
                                            pendingJoin = delete player pendingJoin

                    _ -> error $ "Player: " <> show player <> " cannot join table as it has already started"

        controller dealer can 
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ turn dealer phase == dealer
                    
                    next $ this with community = card :: community

            StartHand : ContractId Table
                with
                    hands : [ContractId Hand]
                do
                    assertWaitingForPlayers phase
                    assert $ length seats > 2
                    
                    table <- create this with 
                        phase = InGame $ PlayerTurn ((head seats).player, BettingRound)
                        seats = zipWith (\seat hand -> seat with revealed = HiddenHand hand) seats hands

                    table <- exercise table Raise with amount = smallBlind
                    table <- exercise table Raise with amount = smallBlind * 2

                    return table

        controller turn dealer phase can
            Check : ContractId Table
                do
                    assert $ turn dealer phase /= dealer
                    let player = turn dealer phase

                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ turn dealer phase /= dealer

                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    seats <- call player seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ turn dealer phase /= dealer
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount player seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assertMsg "Dealer cannot play" $ turn dealer phase /= dealer
                    let player = turn dealer phase

                    assertMsg "Round must be a Betting Round to play AllIn" $ 
                        roundType phase == BettingRound

                    next $
                        this with seats = allIn player seats
