daml 1.2

module Table where

import Cards
import Chips
import Hand
import Seat
import Phase
import SidePot
import DA.List (delete, (!!), head)

turn : Party -> Phase -> Party
turn dealer phase =
    case phase of
        WaitingForPlayers -> dealer  
        PlayerTurn (current, _) -> current
        DealerTurn -> dealer
        Finished _ -> dealer

inShowdown : Phase -> Bool
inShowdown (PlayerTurn (_, ShowdownRound)) = True
inShowdown _ = False
    
split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

findWinners : [Card] -> [Seat] -> Optional EndGame
findWinners community seats =
    case unfolded of
        [winner] ->
            Some $ OneRemaining (winner.player, Seat.pot seats + winner.stack - winner.bet)
        _ ->
            if any (\s -> s.holeCards == None) unfolded then
                None
            else
                Some $ ShowdownWinners (createSidePots community seats)
    where
        (folded, unfolded) = separate (.folded) seats

finish : EndGame -> Table -> Update (ContractId Table)
finish game table = 
    case game of
        ShowdownWinners winners ->
            do
                mapA (\(owner, quantity) -> 
                        create Chips with 
                            owner
                            quantity
                            house = table.house
                            observers = [])
                    $ concatMap allocate winners

                create $ table with phase = Finished $ game
        OneRemaining (owner, quantity) ->
            do
                create Chips with 
                                owner
                                quantity
                                house = table.house
                                observers = []
                
                create $ table with phase = Finished $ game

next : Table -> Update (ContractId Table)
next table =
    case findWinners table.community table.seats of
        Some game ->
            finish game table
--            create table with phase = Finished game
        None ->
            do
                let phase = nextPhase
                                table.community
                                table.seats
                                table.phase
        
                seats <- if inShowdown phase then
                            returnAllRemaining table.house table.seats                        
                         else
                            do return $ table.seats

                create $ table with phase, seats

nextShowdownTurn : Party -> Phase -> Bool
nextShowdownTurn player (PlayerTurn (turn, ShowdownRound)) = player == turn
nextShowdownTurn _ _ = False

nextPlayerTurn : Party -> Phase -> Bool
nextPlayerTurn player (PlayerTurn (turn, _)) = player == turn
nextPlayerTurn _ _ = False

outOfTurnFold : Table -> Update (ContractId Table)
outOfTurnFold table =
    case findWinners table.community table.seats of
        Some game -> finish game table
        None -> create table

returnAllRemaining : Party -> [Seat] -> Update [Seat]
returnAllRemaining house seats =
    mapA (returnRemaining house) seats
 
returnRemaining : Party -> Seat -> Update Seat
returnRemaining house seat =
    if seat.stack > seat.bet then
        do
            create Chips with
                owner = seat.player
                house
                quantity = seat.stack - seat.bet
                observers = []

            return $ seat with stack = seat.bet
    else
        do return seat

finished : Phase -> Bool
finished (Finished _) = True
finished _ = False

signatories : Table -> [Party]
signatories table = 
    case table.phase of
        Finished _ -> [table.house]
        _ -> table.house :: inGame table.seats

createTable : Party -> Party -> Int -> Int -> Update (ContractId Table)
createTable house dealer id smallBlind =
    create Table with
        seats = []
        phase = WaitingForPlayers
        house
        community = []
        dealer
        id
        smallBlind
        observers = []

template TableInvitation
    with
        dealer : Party
        house : Party
        id : Int
        player : Party
    where
        signatory dealer

        controller player can
            AcceptTableInvitation : ContractId Table
                with
                    stack : ContractId Chips
                do
                    exerciseByKey @Table (id, house, dealer) JoinTable with player, stack

template Table
    with        
        seats : [Seat]
        phase : Phase
        house : Party
        community : [Card]
        dealer : Party
        id : Int
        observers : [Party]
        smallBlind : Int
    where
        signatory signatories this

        observer observers

        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        choice JoinTable : ContractId Table
            with 
                player : Party
                stack : ContractId Chips
            controller player, dealer
            do
                assert $ phase == WaitingForPlayers

                chips <- fetch stack
                exercise stack Archive

                let seat = Seat with
                                    stack = chips.quantity
                                    player
                                    bet = 0
                                    folded = False
                                    holeCards = None

                create this with seats = seats ++ [seat]
                
        choice Reveal : ContractId Table
            with
                player : Party
            controller player
            do
                assert $ elem player $ map (.player) seats
                assert $ None == ((.holeCards) $ findSeat player seats)

                hand <- fmap snd $ fetchByKey @Hand (id, player, dealer)

                let cards = (hand.card1, hand.card2)

                let table = this with seats = reveal player cards seats

                if nextShowdownTurn player phase then
                    next table
                else
                    create table

        choice Fold : ContractId Table
            with
                player : Party
            controller player
            do 
                assert $ not $ finished phase
                assert $ elem player $ map (.player) $ filter (not . (.folded)) seats
                
                returnRemaining house $ playerSeat player seats

                let table = this with seats = fold player seats

                if nextPlayerTurn player phase then
                    next table
                else
                    outOfTurnFold table

        controller dealer can 
            DealCommunity : ContractId Table
                with
                    card : Card
                do
                    assert $ phase == DealerTurn
                    
                    next $ this with community = card :: community

            InvitePlayer : ContractId TableInvitation
                with
                    player : Party
                do
                    assert $ not $ elem player $ map (.player) seats
                    assert $ phase == WaitingForPlayers

                    create this with observers = player :: observers

                    create TableInvitation with house, dealer, player, id

            StartHand : ContractId Table
                do
                    assert $ phase == WaitingForPlayers            
                    assert $ length seats > 2

                    table <- create this with phase = PlayerTurn ((head seats).player, BettingRound)
                    table <- exercise table Raise with amount = smallBlind
                    table <- exercise table Raise with amount = smallBlind * 2

                    return table

        controller turn dealer phase can
            Check : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == CheckRound
                    next this

            Call : ContractId Table             
                do
                    assert $ phase /= DealerTurn

                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    seats <- call player seats

                    next $ this with seats

            Raise : ContractId Table
                with
                    amount : Int
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound || roundType phase == CheckRound
                    assert $ amount > 0

                    seats <- raise amount player seats
                    
                    next $ this with seats

            AllIn : ContractId Table
                do
                    assert $ phase /= DealerTurn
                    let player = turn dealer phase

                    assert $ roundType phase == BettingRound

                    next $
                        this with seats = allIn player seats
