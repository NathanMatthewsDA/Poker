daml 1.2

module Round where

import Cards
import Chips
import DA.Foldable (maximum)
import DA.Optional (fromSome, catOptionals)
import DA.List (last, head, tail, replicate)
import Utils
import Hand
import Scoring

data Player = Player with
    player : Party
    stack : Int
    bet : Int
        deriving (Eq, Show)

playerBet : Int -> Player -> Player
playerBet amount player =
    player with stack = player.stack - amount, bet = player.bet + amount

updatePlayer : Int -> Party -> [Player] -> [Player]
updatePlayer amount player =
    map (\p -> if p.player == player then playerBet amount p else p)

data Next =
    Winners [ContractId Chips] |
--    DealerTurn (ContractId DealerPlay) |
    ShowdownRound with
        stakes : [ContractId Chips]
        showdown : ContractId Round |
    NextPlayer (ContractId Round)

current : Party -> [Player] -> Player
current turn players = 
    case find (\p -> p.player == turn) players of
        Some player -> player
        None -> error "Couldnt find player"

currentBet : Party -> [Player] -> Int
currentBet turn players = (current turn players).bet

currentStack : Party -> [Player] -> Int
currentStack turn players = (current turn players).stack

requiredBet : Party -> [Player] -> Int
requiredBet turn players = 
    maximum (map (.bet) players) - currentBet turn players

bet1 : Int -> Round -> Update Round
bet1 amount round =
    case round.phase of
        Betting players -> 
            do
                let required = amount + requiredBet round.turn players

                assert $ required <= currentStack round.turn players

                return $ round with
                                pot = round.pot + required
                                phase = Betting $ updatePlayer required round.turn players
                                turn = nextTurn round
            
        Showdown {} -> error "Cannot Raise Call or Check in Showdown"

nextTurn : Round -> Party
nextTurn round =
    case round.phase of    
        Betting players ->
            fromSome $ findNextLoop (round.turn ==) $ map (.player) players
        Showdown {remaining} ->
            head remaining

allBetsEqual : [Player] -> Bool
allBetsEqual players = allEqual $ map (.bet) players


finishRound : [Player] -> Round -> Update Next
finishRound players round =
    do
        if length round.community < 5 then
            fmap NextPlayer $ create round with turn = round.dealer
        else
            do
                showdown <- create round with 
                                phase = Showdown with 
                                            revealed = []
                                            remaining = map (.player) players
                                turn = nextTurn round


                stakes <- mapA (returnStack round.house) players

                return $ ShowdownRound with
                            stakes = catOptionals stakes
                            showdown 

without : Party -> [Player] -> [Player]
without player players = filter (\p -> p.player /= player) players

fold : Round -> Update Next
fold round =
    case round.phase of
        Betting players ->
            do        
                case without round.turn players of
                    [winner] ->
                        do
                            takings <- create Chips with 
                                            quantity = winner.stack + round.pot
                                            owner = winner.player
                                            house = round.house
                                            observers = []

                            return $ Winners [takings]

                    players ->
                        do
                            let n = round with 
                                        phase = Betting players
                                        turn = nextTurn round

                            if lastCheck round.turn players || lastCall round.turn players then
                                finishRound players n
                            else
                                fmap NextPlayer $ create n
        
        showdown@Showdown {revealed, remaining} ->
            if tail remaining == [] then
                fmap Winners $ splitPot round.house round.pot $ winning round.community revealed 
            else
                fmap NextPlayer $ create round with phase = showdown with remaining = tail remaining


lastCall : Party -> [Player] -> Bool
lastCall turn players = 
    allEqual otherBets && not (any (bet ==) otherBets)
    where
        bet = currentBet turn players
        otherBets = map (.bet) $ without turn players

lastCheck : Party -> [Player] -> Bool
lastCheck turn players = allBetsEqual players && turn == (last players).player

returnStack : Party -> Player -> Update ReturnStack
returnStack house (Player {stack, player}) = 
    do
        if stack == 0 then
            return None
        else
            do
                chips <-
                    create Chips with 
                        quantity = stack
                        owner = player
                        house = house
                        observers = []
                return $ Some chips
        
returnCurrentStack : Round -> Update ReturnStack
returnCurrentStack round =
    case round.phase of
        Betting players ->
            returnStack round.house (fromSome $ find (\p -> p.player == round.turn) players)
        Showdown {} ->
            return None

data Phase =
    Betting [Player] |
    Showdown with
        revealed : [(Party, Card, Card)]
        remaining : [Party]
            deriving (Eq, Show)

winning : [Card] -> [(Party, Card, Card)] -> [Party]
winning community revealed =
    map (\(p, _, _) -> p) $ maxOn (\(_, c1, c2) -> handRank (c1 :: c2 :: community)) revealed

intSplit : Int -> Int -> [Int]
intSplit numer denom =
    replicate extra (share + 1) ++ replicate (denom - extra) share
    where
        extra = numer % denom
        share = numer / denom

splitPot : Party -> Int -> [Party] -> Update [ContractId Chips]
splitPot house amount parties =     
    sequence $ zipWith (\owner quantity -> create Chips with owner, quantity, house, observers = []) 
        parties (intSplit amount (length parties))

signatories : Round -> [Party]
signatories round =
    round.house :: (case round.phase of
                        Betting players -> 
                            map (.player) players
                        Showdown {revealed, remaining} -> 
                            winning round.community revealed ++ remaining)

addCommunityCards : [Card] -> Round -> Update (ContractId Round)
addCommunityCards cards round = 
    case round.phase of
        Betting players ->
            do
                assert $ round.turn == round.dealer

                create round with
                    community = cards ++ round.community
                    turn = (head players).player
        Showdown {} ->
            error ""

template Round
    with        
        pot : Int
        phase : Phase
        -- players : [Player]
        house : Party
        community : [Card]
        dealer : Party
        turn : Party
        id : Int    
    where
        signatory signatories this
        
        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        controller turn can
            DealFlop : ContractId Round
                with
                    card1 : Card
                    card2 : Card
                    card3 : Card
                do
                    assert $ community == []
                    addCommunityCards [card1, card2, card3] this

            DealTurn : ContractId Round
                with
                    card : Card
                do
                    assert $ length community == 3
                    addCommunityCards [card] this

            DealRiver : ContractId Round
                with
                    card : Card
                do
                    assert $ length community == 4
                    addCommunityCards [card] this

            CallOrCheck : Next                
                do
                    case phase of
                        Betting players ->
                            do
                                assert $ turn /= dealer
                                round <- bet1 0 this

                                if lastCheck turn players || lastCall turn players then
                                    finishRound players round
                                else
                                    fmap NextPlayer $ create round
                        Showdown {} ->
                            error "Can't call or check in showdown"
                
            Raise : ContractId Round
                with
                    amount : Int
                do
                    assert $ turn /= dealer
                    assert $ amount > 0
                    round <- bet1 amount this
                    create round
            
            Reveal : Next
                do
                    case phase of
                        Betting _ ->
                            error "Cannot reveal hand before Showdown"              
                        Showdown {revealed, remaining} ->
                            do
                                (handId, hand) <- fetchByKey @Hand (id, head remaining, dealer)

                                let r = (head remaining, hand.card1, hand.card2) :: revealed
                                
                                if tail remaining == [] then                        
                                    fmap Winners $ splitPot house pot $ winning community r
                                else
                                    fmap NextPlayer $ create this with phase = Showdown with
                                                                                    revealed = r
                                                                                    remaining = tail remaining

            Fold : (ReturnStack, Next)
                do
                    assert $ turn /= dealer
                    next <- fold this
                    toReturn <- returnCurrentStack this

                    return (toReturn, next)
