daml 1.2

module Round where

import Cards
import Chips
import DA.Foldable (maximum)
import DA.Optional (fromSome, catOptionals)
import DA.List ((!!), last, head, tail, replicate, elemIndex)
import Utils
import Hand
import Scoring

data Phase =
    BettingRound [Int] |
    CheckRound |
    Showdown [(Party, Card, Card)]
        deriving (Eq, Show)

data Next =
    Winners [ContractId Chips] |
    ShowdownRound with
        stakes : [ContractId Chips]
        showdown : ContractId Round |
    NextPlayer (ContractId Round)

currentPlayerIndex : Round -> Optional Int
currentPlayerIndex round = elemIndex round.current round.players

nextTurn : Round -> Party
nextTurn round =
    case currentPlayerIndex round of
        Some index ->
            case round.phase of 
                CheckRound | nextIndex == 0 && not river ->
                    round.dealer
                BettingRound bets | allEqual bets && not river ->
                    round.dealer
                _ ->
                    round.players !! nextIndex 
            where
                nextIndex = (index + 1) % length round.players
                river = length round.community == 5
        None ->
            if round.current == round.dealer then
                head round.players
            else
                error ""

finishRound : Round -> Update Next
finishRound round =
    if length round.community == 5 then
        do
            showdown <- create round with phase = Showdown []

            stakes <- sequence $ zipWith 
                                        (\owner quantity -> 
                                            create Chips with owner, quantity, house = round.house, observers = [])
                                        round.players
                                        round.stacks

            return $ ShowdownRound with stakes, showdown
    else
        fmap NextPlayer $ create round with 
                            phase = CheckRound
                            current = round.dealer

next : Round -> Update Next
next round =
    case round.phase of
        CheckRound | round.current == head (round.players) ->
            finishRound round
        BettingRound bets | allEqual bets ->
            finishRound round
        Showdown revealed ->
            case round.players of
                [last] | revealed == [] ->
                    do
                        winnings <- create Chips with   
                                        owner = last
                                        house = round.house
                                        quantity = round.pot
                                        observers = []

                        return $ Winners [winnings]
                [] ->
                    do
                        let winners = winning round.community revealed

                        winnings <- splitPot round.house round.pot winners

                        return $ Winners winnings
                _ ->
                    do fmap NextPlayer $ create round
        _ -> 
            fmap NextPlayer $ create round

applyBet : Int -> Round -> Update Round
applyBet amount round =
    case round.phase of
        CheckRound | amount == 0 ->
            do return round with current
        CheckRound ->
            do 
                assert $ round.stacks !! index >= amount
                return $
                    round with 
                        phase = BettingRound (setAt index amount (replicate (length round.players) 0))
                        stacks = updateAt index (\s -> s - amount) round.stacks
                        current
        BettingRound bets ->
            do
                assert $ round.stacks !! index >= required            
                return $
                    round with 
                        phase = BettingRound (updateAt index (required +) bets)
                        stacks = updateAt index (\s -> s - required) round.stacks
                        current
            where
                required = maximum bets - (bets !! index) + amount
                                            
        Showdown {} -> error "Cannot Raise Call or Check in Showdown"
    where
        index = fromSome $ currentPlayerIndex round
        current = round.players !! ((index + 1) % length round.players)

deletePlayer : Round -> Round
deletePlayer round =
    round with
        players = deleteAt index round.players
        stacks = deleteAt index round.stacks
        phase = case round.phase of
                    BettingRound bets -> BettingRound (deleteAt index bets)
                    phase -> phase
        current = round.players !! ((index + 1) % length round.players)
    where
        index = fromSome $ currentPlayerIndex round
        
returnCurrentStack : Round -> Update ReturnStack
returnCurrentStack round =
    case currentPlayerIndex round of
        Some index ->
            if round.stacks !! index == 0 then
                return None
            else
                do
                    chips <-
                        create Chips with 
                            quantity = round.stacks !! index
                            owner = round.players !! index
                            house = round.house
                            observers = []
                    return $ Some chips
        None ->
            error ""

winning : [Card] -> [(Party, Card, Card)] -> [Party]
winning community revealed =
    map (\(p, _, _) -> p) $ maxOn (\(_, c1, c2) -> handRank (c1 :: c2 :: community)) revealed

intSplit : Int -> Int -> [Int]
intSplit numer denom =
    replicate extra (share + 1) ++ replicate (denom - extra) share
    where
        extra = numer % denom
        share = numer / denom

splitPot : Party -> Int -> [Party] -> Update [ContractId Chips]
splitPot house amount parties =     
    sequence $ zipWith (\owner quantity -> create Chips with owner, quantity, house, observers = []) 
        parties (intSplit amount (length parties))

signatories : Round -> [Party]
signatories round =
    round.house :: round.players ++ 
        case round.phase of
            Showdown revealed -> winning round.community revealed
            _ -> []

addCommunityCard : Card -> Round -> Update (ContractId Round)
addCommunityCard card round = 
    do
        assert $ round.current == round.dealer

        let community = card :: round.community

        create round with 
            community
            phase = CheckRound
            current = if length community < 3 then
                        round.dealer
                      else 
                        head round.players

template Round
    with        
        pot : Int
        stacks : [Int]
        phase : Phase
        players : [Party]
        house : Party
        community : [Card]
        dealer : Party
        id : Int
        current : Party
    where
        signatory signatories this
        
        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        controller current can
            DealCommunity : ContractId Round
                with
                    card : Card
                do
                    addCommunityCard card this

            CallOrCheck : Next                
                do
                    assert $ current /= dealer

                    round <- applyBet 0 this

                    next round

            Raise : ContractId Round
                with
                    amount : Int
                do
                    assert $ current /= dealer
                    assert $ amount > 0

                    round <- applyBet amount this
                    create round
            
            Reveal : Next
                do
                    case phase of
                        BettingRound _ ->
                            error "Cannot reveal hand before Showdown"
                        CheckRound ->
                            error "Cannot reveal hand before Showdown"

                        Showdown revealed ->
                            do
                                (handId, hand) <- fetchByKey @Hand (id, head players, dealer)

                                let r = (head players, hand.card1, hand.card2) :: revealed
                                
                                next $ this with 
                                    phase = Showdown r
                                    players = tail players
                                    current = head (tail players)
                                                                                    
            Fold : (ReturnStack, Next)
                do
                    assert $ current /= dealer

                    round <- next (deletePlayer this)
                    toReturn <- returnCurrentStack this

                    return (toReturn, round)
