daml 1.2

module Round where

import Cards
import Chips
import DA.Foldable (maximum)
import DA.Optional (fromSome, catOptionals)
import DA.List ((!!), last, head, tail, replicate, elemIndex)
import Utils
import Hand
import Scoring

-- data Awaiting = CommunityCard | Player Int deriving (Eq, Show)

data Phase =
    BettingRound [Int] |
    CheckRound |
    Showdown [(Party, Card, Card)]
        deriving (Eq, Show)

data Next =
    Winners [ContractId Chips] |
    ShowdownRound with
        stakes : [ContractId Chips]
        showdown : ContractId Round |
    NextPlayer (ContractId Round)

currentPlayerIndex : Round -> Optional Int
currentPlayerIndex round = elemIndex round.current round.players

-- button : Round -> Boolean
-- button round = round.current == last (round.players)

nextTurn : Round -> Party
nextTurn round =
    case currentPlayerIndex round of
        Some index ->
            case round.phase of 
                CheckRound | nextIndex == 0 && not river ->
                    round.dealer
                BettingRound bets | allEqual bets && not river ->
                    round.dealer
                _ ->
                    round.players !! nextIndex 
            where
                nextIndex = (index + 1) % length round.players
                river = length round.community == 5
        None ->
            if round.current == round.dealer then
                head round.players
            else
                error ""

finishRound : Round -> Update Next
finishRound round =
    if length round.community == 5 then
        do
            showdown <- create round with phase = Showdown []

            stakes <- sequence $ zipWith 
                                        (\owner quantity -> 
                                            create Chips with owner, quantity, house = round.house, observers = [])
                                        round.players
                                        round.stacks

            return $ ShowdownRound with stakes, showdown
    else
        fmap NextPlayer $ create round with current = round.dealer

next : Round -> Update Next
next round =
    case round.phase of
        CheckRound | round.current == head (round.players) ->
            finishRound round
        BettingRound bets | allEqual bets ->
            finishRound round
        _ -> 
            fmap NextPlayer $ create round

        -- Showdown revealed ->
        --     case round.players of
        --         [last] | revealed == [] ->
        --             do
        --                 winnings <- create Chips with   
        --                                 owner = last
        --                                 house = round.house
        --                                 quantity = round.pot
        --                                 observers = []

        --                 return $ Winners [winnings]
        --         [] ->
        --             do
        --                 let winners = winning round.community revealed

        --                 winnings <- splitPot round.house round.pot winners

        --                 return $ Winners winnings
        --         _ ->
        --             do fmap NextPlayer $ create round


applyBet : Int -> Round -> Update Round
applyBet amount round =
    case round.phase of
        CheckRound | amount == 0 ->
            do return round with current
        CheckRound ->
            do 
                assert $ round.stacks !! index >= amount
                return $
                    round with 
                        phase = BettingRound (setAt index amount (replicate (length round.players) 0))
                        stacks = updateAt index (\s -> s - amount) round.stacks
                        current
        BettingRound bets ->
            do
                assert $ round.stacks !! index >= required            
                return $
                    round with 
                        phase = BettingRound (updateAt index (required +) bets)
                        stacks = updateAt index (\s -> s - required) round.stacks
                        current
            where
                required = maximum bets - (bets !! index) + amount
                                            
        Showdown {} -> error "Cannot Raise Call or Check in Showdown"
    where
        index = fromSome $ currentPlayerIndex round
        current = round.players !! ((index + 1) % length round.players)

deletePlayer : Round -> Round
deletePlayer round =
    case round.phase of
        BettingRound bets ->
            round with
                current = players !! newIndex
                stacks = deleteAt index round.stacks
                players
                phase = BettingRound (deleteAt index bets)
            where
                index = fromSome $ currentPlayerIndex round
                players = deleteAt index round.players
                newIndex = index % (length players)
        Showdown _  -> 
            round with 
                players = tail round.players
                current = head (tail round.players)



-- fold : Round -> Update Next
-- fold round =
--     case round.phase of
--         Betting {awaiting = Player index, stacks, bets} ->
--             if length round.players == 1 then
--                 do
--                     takings <- create Chips with 
--                                     quantity = head stacks + round.pot
--                                     owner = head round.players
--                                     house = round.house
--                                     observers = []

--                     return $ Winners [takings]
--             else
--                 next (allEqual bets) round
        
--         Showdown revealed ->
--             if tail remaining == [] then
--                 fmap Winners $ splitPot round.house round.pot $ winning round.community revealed 
--             else
--                 fmap NextPlayer $ create round with 
--                                                 phase = Showdown with
--                                                             remaining = tail remaining
--                                                             revealed
--                                                 turn = head remaining

-- returnStack : Party -> Player -> Update ReturnStack
-- returnStack house (Player {stack, player}) = 
--     do
--         if stack == 0 then
--             return None
--         else
--             do
--                 chips <-
--                     create Chips with 
--                         quantity = stack
--                         owner = player
--                         house = house
--                         observers = []
--                 return $ Some chips
        
returnCurrentStack : Round -> Update ReturnStack
returnCurrentStack round =
    case currentPlayerIndex round of
        Some index ->
            if round.stacks !! index == 0 then
                return None
            else
                do
                    chips <-
                        create Chips with 
                            quantity = round.stacks !! index
                            owner = round.players !! index
                            house = round.house
                            observers = []
                    return $ Some chips
        None ->
            error ""


winning : [Card] -> [(Party, Card, Card)] -> [Party]
winning community revealed =
    map (\(p, _, _) -> p) $ maxOn (\(_, c1, c2) -> handRank (c1 :: c2 :: community)) revealed

intSplit : Int -> Int -> [Int]
intSplit numer denom =
    replicate extra (share + 1) ++ replicate (denom - extra) share
    where
        extra = numer % denom
        share = numer / denom

splitPot : Party -> Int -> [Party] -> Update [ContractId Chips]
splitPot house amount parties =     
    sequence $ zipWith (\owner quantity -> create Chips with owner, quantity, house, observers = []) 
        parties (intSplit amount (length parties))

signatories : Round -> [Party]
signatories round =
    round.house :: round.players ++ 
        case round.phase of
            Showdown revealed -> winning round.community revealed
            _ -> []

addCommunityCards : [Card] -> Round -> Update (ContractId Round)
addCommunityCards cards round = 
    do
        assert $ round.current == round.dealer

        create round with community = cards ++ round.community

-- currentTurn : Round -> Party
-- currentTurn round =
--     case round.phase of
--         Showdown _ -> head round.players
--         Betting {awaiting = Player index} -> round.players !! index
--         Betting {awaiting = CommunityCard} -> round.dealer

--createWinners : Round -> Update Next



template Round
    with        
        pot : Int
        stacks : [Int]
        phase : Phase
        players : [Party]
        house : Party
        community : [Card]
        dealer : Party
        id : Int
        current : Party
    where
        signatory signatories this
        
        key (id, house, dealer) : (Int, Party, Party)

        maintainer key._2

        controller current can
            DealFlop : ContractId Round
                with
                    card1 : Card
                    card2 : Card
                    card3 : Card
                do
                    assert $ community == []

                    addCommunityCards [card1, card2, card3] this

            DealTurn : ContractId Round
                with
                    card : Card
                do
                    assert $ length community == 3
                    addCommunityCards [card] this

            DealRiver : ContractId Round
                with
                    card : Card
                do
                    assert $ length community == 4
                    addCommunityCards [card] this

            CallOrCheck : Next                
                do
                    assert $ current /= dealer

                    round <- applyBet 0 this

                    next round

            Raise : ContractId Round
                with
                    amount : Int
                do
                    assert $ current /= dealer
                    assert $ amount > 0

                    round <- applyBet amount this
                    create round
            
            Reveal : Next
                do
                    case phase of
                        BettingRound _ ->
                            error "Cannot reveal hand before Showdown"
                        CheckRound ->
                            error "Cannot reveal hand before Showdown"

                        Showdown revealed ->
                            do
                                (handId, hand) <- fetchByKey @Hand (id, head players, dealer)

                                let r = (head players, hand.card1, hand.card2) :: revealed
                                
                                next $ this with 
                                    phase = Showdown r
                                    players = tail players
                                    current = head (tail players)
                                                                                    
            Fold : (ReturnStack, Next)
                do
                    assert $ current /= dealer

                    round <- next (deletePlayer this)
                    toReturn <- returnCurrentStack this

                    return (toReturn, round)
