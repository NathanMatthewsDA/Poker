daml 1.2

module Round where

import Cards
import Chips
import DA.List (elemIndex, delete, (!!), head, tail)
import DA.Tuple (swap)
import DA.Foldable (maximum)
import DA.Optional (fromSome, fromOptional)
import SidePot (createSidePots1, allocate)

type Stack = Int
type Stake = Int

data Limits = Limits with
    smallBlind : Int
    bigBlind : Int
    tableStake : Stake
    maxBuyIn : Stake
       deriving (Eq, Show)

template Unturned 
    with
        dealer : Party
        card : Card
    where
        signatory dealer

template PlayerCard
    with
        dealer : Party
        player : Party
        card : Card
    where
        signatory dealer
        observer player 

data Game = Game with
    limits : Limits
    players : [Party]
    dealer : Party
    chips : ContractId SharedChips
    invited : [Party]
    stacks : [Stack]
        deriving (Eq, Show)

rotateButton : Game -> Game
rotateButton game =
    game with
        players = rotate game.players
        stacks = rotate game.stacks
        
data Round = Round with
    game : Game
    hands : [(ContractId PlayerCard, ContractId PlayerCard)]
    stakes : [Stake]
    active : [Party]
    unturned : [ContractId Unturned]
    community : [Card]
    lastRaise : Party
        deriving (Eq, Show)

checkChips : Round -> Update ()
checkChips round = do
    total <- fmap (.quantity) $ fetch round.game.chips
    assert $ total == sum round.stakes + sum round.game.stacks
    return ()

playerIndex : Party -> Game -> Int
playerIndex player game = 
    case elemIndex player game.players of
        Some index -> index
        None -> error $ "Player: " <> show player <> " not seated at table"

stakeFor : Round -> Party -> Stake
stakeFor round player = round.stakes !! (playerIndex player round.game)

stackFor : Game -> Party -> Stake
stackFor game player = game.stacks !! (playerIndex player game)

inPlay : Round -> Party -> Bool
inPlay round player = stackFor round.game player > 0 && elem player round.active

toPlay : Round -> [Party]
toPlay round = filter (inPlay round) round.active

maxStake : Round -> Stake
maxStake round = maximum round.stakes

stakesEqual : Round -> Bool
stakesEqual round = all (maxStake round ==) $ map (stakeFor round) $ toPlay round

fold : Party -> Round -> Round
fold player round = round with active = delete player round.active

setAt : Int -> a -> [a] -> [a]
setAt index x xs = (take index xs) ++ (x :: (drop (index + 1) xs)) 

updateAt : Int -> (a -> a) -> [a] -> [a]
updateAt index f xs = (take index xs) ++ (f (xs !! index) :: (drop (index + 1) xs))

increaseStake : Int -> Party -> Round -> Round
increaseStake amount player round =
    round with 
            game = round.game with stacks = updateAt index 
                                                (\s -> s - amount)
                                                round.game.stacks
            stakes = updateAt index (amount +) round.stakes
    where
        index = playerIndex player round.game

bet : Int -> Party -> Round -> Round
bet amount player round = 
    if amount > stack then
        error $ "Player: " <> show player <> 
                " attempted to bet: " <> show amount <>
                " which is more than they have avaliable: " <> show stack
    else if amount < required && amount < stack then
        error $ "Player: " <> show player <> 
                " attempted to bet: " <> show amount <>
                " which is less than required: " <> show required
    else
        increaseStake amount player round
    where
        stack = stackFor round.game player
        required = maxStake round - (stakeFor round player)

allinOrRequired : Party -> Round -> Round
allinOrRequired player round = 
    increaseStake (min stack required) player round 
    where
        stack = stackFor round.game player
        required = maxStake round - (stakeFor round player)

rotateTo : (a -> Bool) -> [a] -> [a]
rotateTo p = (uncurry (++)) . swap . break p

rotate : [a] -> [a]
rotate [] = []
rotate (x :: xs) = xs ++ [x]

handFor : Round -> Party -> (ContractId PlayerCard, ContractId PlayerCard)
handFor round player = round.hands !! (playerIndex player round.game)

nextPlay : Party -> Round -> Party
nextPlay played round =
    head $ filter (inPlay round) $ tail $ rotateTo (played ==) round.game.players

allin : Game -> [Party]
allin game = map fst $ filter ((0 ==) . snd) $ zip game.players game.stacks

removeAllin : Game -> Game
removeAllin game =
    game with
        players = filter (\p -> not (elem p (allin game))) game.players
        stacks = delete 0 game.stacks

deal : Party -> [Party] -> [Card] -> Update [ContractId PlayerCard]
deal dealer players cards =
    mapA (\(player, card) -> create PlayerCard with dealer, player, card) $ zip players cards

deleteAt : Int -> [a] -> [a]
deleteAt n xs = take n xs ++ drop (n + 1) xs

insertAt : Int -> a -> [a] -> [a]
insertAt n x xs = take n xs ++ (x :: drop n xs)

turnCard : Round -> Update Round 
turnCard round = do
    card <- fmap (.card) $ fetch (head round.unturned)
    return round with community = round.community ++ [card], unturned = tail round.unturned

turnAllCards : Round -> Update Round
turnAllCards round =
    if round.unturned == [] then
        return round
    else do
        round <- turnCard round
        turnAllCards round

calculateWinnings : [(Party, (Card, Card))] -> [Card] -> [Stake] -> [Party] -> [Stack]
calculateWinnings revealed community stakes players =
    map (\p -> fromOptional 0 $ lookup p allocations) players
    where
        stakeFor player = stakes !! (fromSome $ elemIndex player players)
        active = map fst revealed
        folded = filter (\p -> not (elem p active)) $ players
        sidePots = createSidePots1 
                        community 
                        (map stakeFor folded)
                        (zipWith (\(player, cards) stake -> (player, stake, cards)) revealed stakes)
        allocations = concatMap allocate sidePots 

