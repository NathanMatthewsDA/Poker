daml 1.2

module Table2 where

import Chips
import Seat (Hand (..), PlayerSeed (..))
import Table ()
import Cards
import Phase (Round (..))
import Utils
import Random (shuffle)

import SidePot (createSidePots1, SidePot)

import DA.Action (foldlA)
import DA.Optional (mapOptional, isSome, isNone, catOptionals)
import DA.List (head, tail, (!!), last)
import DA.Foldable (maximum)
import DA.Either (isLeft, isRight, partitionEithers)

data Table = Table
    with
        dealer : Party
        players : [Party]
        smallBlind : Int
        invited : [Party]
    deriving (Eq, Show)

data RoundState = RoundState
    with
        table : Table
        stacks : [Optional (ContractId Chips)]
        bets : [Int]
        folded : [Party]
        pot : ContractId Chips
        unturned : [ContractId CommunityCard]
        community : [Card]
        revealed : [Either (Card, Card) (ContractId Hand)]
    deriving (Eq, Show)

getSeed : PendingHand -> Update Int
getSeed pending = 
    do
        assert $ all isSome pending.seeds

        seeds <- mapA fetch $ catOptionals pending.seeds 

        assert $ map (.player) seeds == pending.table.players

        return $ sum $ map (.seed) seeds

template CommunityCard
    with
        dealer : Party
        card : Card
    where
        signatory dealer

startGame : ContractId PendingHand -> Update (ContractId PlayerTurn)
startGame pending = 
    do  
        p <- fetch pending
        seed <- getSeed p

        let shuffled = shuffle seed deck

        let n = length p.table.players
        
        let pairs = zip shuffled (drop n shuffled)
        let dealer = p.table.dealer

        hands <- sequence $ zipWith (\holder (card1, card2) -> 
                                        create Hand with
                                            holder
                                            dealer
                                            card1
                                            card2
                                            obs = [])
                                p.table.players
                                pairs
                                
        community <- mapA (\card -> create CommunityCard with dealer, card) $ 
            take 5 $ drop (n * 2) shuffled

        exercise pending StartGame with hands, community 

createPending : Party -> Party -> Int -> ContractId Chips -> Update (ContractId PendingHand)
createPending dealer player smallBlind stack =
    do
        create PendingHand with
            table = Table with
                        dealer
                        players = [player]
                        smallBlind
                        invited = []
            stacks = [stack]
            seeds = [None]

playerReady : Party -> Int -> ContractId PendingHand -> Update (ContractId PendingHand)
playerReady player seed pending =
    do
        dealer <- fmap ((.dealer) . (.table)) $ fetch pending

        seed <- create PlayerSeed with player, dealer, seed

        exercise pending PlayerReady with player, seed

template PendingHand
    with
        table : Table
        stacks : [ContractId Chips]
        seeds : [Optional (ContractId PlayerSeed)]
    where
        signatory table.players
        observer table.invited

        choice InvitePlayer : ContractId PendingHand
            with
                player : Party
                inviter : Party
            controller inviter
            do
                assertMsg ("Inviter: " <> show inviter <> " is not currently a member of table, current members: " <> show table.players)
                    $ elem inviter table.players

                assert $ not $ elem player table.players
                
                stacks <- sequence $ 
                            zipWith (\p s -> exercise s AddObserver with adder = p, obs = player)
                                table.players
                                stacks

                create this with 
                    table = table with invited = player :: table.invited
                    stacks

        choice JoinTable : ContractId PendingHand
            with
                player : Party
                stack : ContractId Chips
            controller player
            do
                assert $ elem player table.invited

                stack <- foldlA (\s p -> exercise s AddObserver with adder = player, obs = p) stack table.players

                create this with
                    table = table with players = player :: table.players
                    stacks = stack :: stacks
                    seeds = None :: seeds

        choice LeaveTable : ContractId PendingHand
            with
                player : Party
            controller player
            do
                assert $ elem player table.players

                let index = indexOf player table.players

                create this with
                    table = table with players = deleteAt index table.players
                    seeds = deleteAt index seeds

        choice PlayerReady : ContractId PendingHand
            with
                player : Party
                seed : ContractId PlayerSeed
            controller player
            do
                assert $ elem player table.players

                create this with 
                    seeds = setAt (indexOf player table.players) (Some seed) seeds
        
        controller table.dealer can 
            StartGame : ContractId PlayerTurn
                with
                    hands : [ContractId Hand]
                    community : [ContractId CommunityCard]
                do
                    let l = length table.players
                    -- assert $ all isSome seeds
                    assert $ l > 1
                    assert $ length community == 5
                    assert $ l == length hands

                    let bigBlind = table.smallBlind * 2

                    (sb, remaining0) <- exercise (stacks !! 0) Split with amount = table.smallBlind
                    (bb, remaining1) <- exercise (stacks !! 1) Split with amount = bigBlind

                    pot <- exercise sb Merge with chips = bb, chipsOwners = [table.players !! 1]

                    let bets = table.smallBlind :: bigBlind :: replicate (l - 2) 0
                    let newStacks = map Some $ remaining0 :: remaining1 :: drop 2 stacks

                    create PlayerTurn
                        with
                            state = RoundState
                                        with
                                            table
                                            stacks = newStacks
                                            bets
                                            folded = []
                                            pot
                                            unturned = community
                                            community = []
                                            revealed = map Right hands

                            round = BettingRound
                            turn = table.players !! (l % 3)

optionalOnSnd : (a, Optional b) -> Optional (a, b)
optionalOnSnd (a, Some b) = Some (a, b)
optionalOnSnd (a, None) = None

template Finished
    with 
       table : Table
       folded : [Party]
       stacks : [Optional (ContractId Chips)]
       unturned : [ContractId CommunityCard]
       community : [Card]
       revealed : [Either (Card, Card) (ContractId Hand)]
    where
        signatory table.players

        choice NextHand : ContractId PendingHand
            controller table.players
            do
                let (p, s) = unzip $ mapOptional optionalOnSnd $ zip table.players stacks

                create PendingHand with
                    table = table with players = rotate p
                    stacks = rotate s
                    seeds = replicate (length p) None

        choice ShowHand : ContractId Finished
            with
                player : Party
            controller player
            do
                -- ssert $ elem player $ table.players
                
                -- let index = indexOf player table.players

                -- hand <- fetch $ state.handIds !! index

                -- assert $ hand.dealer == state.table.dealer

                -- let revealed = setAt index (Right (hand.card1, hand.card2)) state.revealed

                error "TODO"
            
template DealerTurn
    with
        state : RoundState
    where
        signatory state.table.players

        controller state.table.dealer can 
            TurnCommunity : Next
                do
                    assert $ state.unturned /= []

                    (turned, unturned) <- 
                                if length (activePlayers state) < 2 then
                                    do  
                                        cards <- mapA (fmap (.card) . fetch) state.unturned               
                                        return $ (cards, [])                                        
                                else if length state.community == 0 then
                                    do
                                        cards <- mapA (fmap (.card) . fetch) $ take 3 state.unturned
                                        return $ (cards, drop 3 state.unturned)
                                else
                                    do
                                        card <- fmap (.card) $ fetch $ head state.unturned
                                        return $ ([card], tail state.unturned)

                    let community = state.community ++ turned

                    if length (activePlayers state) < 2 then
                        do
                            fmap AwaitingPlayer $
                                create PlayerTurn with
                                    state = state with community, unturned
                                    turn = head $ toReveal state
                                    round = ShowdownRound
                    else
                        do
                            fmap AwaitingPlayer $
                                create PlayerTurn with
                                    state = state with community, unturned
                                    turn = head $ activePlayers state
                                    round = CheckRound

type NextTurn = Either (ContractId PlayerTurn) (ContractId DealerTurn)

split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

splitPot : ContractId Chips -> [(Party, Int)] -> Update [(Party, ContractId Chips)]

splitPot pot [] = error ""
splitPot pot [(player, cut)] =
    do
        p <- fetch pot
        assert $ p.quantity == cut
        pot <- exercise pot TakeOwnership with owner = player
        return [(player, pot)]

splitPot pot ((player, cut) :: cuts) =        
    do
        (forPlayer, pot) <- exercise pot Split with amount = cut
        forPlayer <- exercise forPlayer TakeOwnership with owner = player
        remaining <- splitPot pot cuts
        return $ (player, forPlayer) :: remaining


finish : RoundState -> Update (ContractId Finished)
finish state =
    do
        let (unfolded, folded) = 
                partitionEithers $
                    zipWith3 (\player bet revealed ->
                                case revealed of
                                    Left r -> Left (player, bet, r)
                                    Right _ -> Right bet)
                        state.table.players
                        state.bets
                        state.revealed

        let pots = createSidePots1 state.community folded unfolded

        let allocation = concatMap allocate pots

        shares <- splitPot state.pot allocation

        stacks <- sequence $ 
                    zipWith (\player stack ->
                                do
                                    let share = fmap snd $ find ((player ==) . fst) shares 

                                    case (share, stack) of
                                        (None, None) -> return None
                                        (Some share, None) -> return $ Some share
                                        (None, Some stack) -> return $ Some stack
                                        (Some share, Some stack) ->
                                            do
                                                chips <- exercise stack Merge with chips = share, chipsOwners = [player]
                                                return $ Some chips)
                        state.table.players
                        state.stacks

        create Finished with
            table = state.table
            folded = state.folded
            stacks
            unturned = state.unturned
            community = state.community
            revealed = state.revealed
  
data Next = 
    HandFinished (ContractId Finished) |
    AwaitingDealer (ContractId DealerTurn) |
    AwaitingPlayer (ContractId PlayerTurn)

fromAwaitingPlayer : Next -> ContractId PlayerTurn
fromAwaitingPlayer (AwaitingPlayer turn) = turn
fromAwaitingPlayer _ = error "Not AwaitingPlayer"

fromAwaitingDealer : Next -> ContractId DealerTurn
fromAwaitingDealer (AwaitingDealer turn) = turn
fromAwaitingDealer _ = error "Not AwaitingDealer"

fromHandFinished : Next -> ContractId Finished
fromHandFinished (HandFinished finished) = finished
fromHandFinished _ = error "Not HandFinished"

placeBet : Int -> Party -> RoundState -> Update RoundState
placeBet amount player state =
    case state.stacks !! index of
        Some stack ->
            do
                s <- fetch stack

                assertMsg ("Stack quantity: " <> show s.quantity <> 
                            " for player: " <> show player <> 
                            " is not enough for placed bet: " 
                                <> show amount) $ s.quantity >= amount

                (toAdd, remaining) <- if s.quantity == amount then
                                            do return (stack, None)
                                        else
                                            do
                                               (toAdd, remaining) <- 
                                                exercise stack Split with amount
                                               return (toAdd, Some remaining)

                pot <- exercise state.pot Merge with 
                                    chips = toAdd
                                    chipsOwners = [player]

                return $ state with pot
                                    stacks = setAt index remaining state.stacks
                                    bets = updateAt index (amount +) state.bets
        None ->
            error $ "Cannot place bet of: " <> show amount <> " for player: " <>
                        show player <> " as there is no table stack left"
    where
        index = indexOf player state.table.players

placeRequiredAnd : Int -> Party -> RoundState -> Update RoundState
placeRequiredAnd amount player state =
    placeBet (amount + required) player state
    where
        index = indexOf player state.table.players
        required = maximum state.bets - state.bets !! index
 
lastCheck : RoundState -> Party
lastCheck = last . activePlayers

nextTurn : Party -> RoundState -> Party
nextTurn player state = findNext player $ inPlay state

inPlay : RoundState -> [Party]
inPlay state = filter (\p -> not (elem p state.folded)) state.table.players

activePlayers : RoundState -> [Party]
activePlayers state = 
    map fst $
    filter (\(player, stack) -> isSome stack && not (elem player state.folded)) $
    zip state.table.players state.stacks
    
findNext : (Eq a) => a -> [a] -> a
findNext x xs = head $ tail $ dropWhile (x /=) $ xs ++ xs

startingAfter : (a -> Bool) -> [a] -> [a]
startingAfter p xs = e ++ s ++ [x] where (s, (x :: e)) = break p xs
        
currentStack : Party -> RoundState -> Optional (ContractId Chips)
currentStack player state = 
    state.stacks !! indexOf player state.table.players

active : Party -> RoundState -> Bool
active player state = 
    not (elem player state.folded) && isSome (currentStack player state)

nextActivePlayer : Party -> RoundState -> Party
nextActivePlayer player state = 
    head $ filter (\p -> active p state) $ startingAfter (player ==) state.table.players

currentRevealed : Party -> RoundState -> Either (Card, Card) (ContractId Hand)
currentRevealed player state = 
    state.revealed !! indexOf player state.table.players

requireReveal : Party -> RoundState -> Bool
requireReveal player state = 
    not (elem player state.folded) && isRight (currentRevealed player state)

nextToReveal : Party -> RoundState -> Party
nextToReveal player state = 
    head $ filter (\p -> requireReveal p state) $ startingAfter (player ==) state.table.players

toReveal : RoundState -> [Party]
toReveal state =
    map fst $
    filter (\(player, revealed) -> isRight revealed && not (elem player state.folded)) $
    zip state.table.players state.revealed

currentBet : Party -> RoundState -> Int
currentBet player state = state.bets !! indexOf player state.table.players

activeBets : RoundState -> [Int]
activeBets state = map (\p -> currentBet p state) $ activePlayers state

finishRound : Party -> RoundState -> Update Next
finishRound turn state = 
  if length state.community == 5 then
            fmap AwaitingPlayer $
                create PlayerTurn with 
                    state
                    turn = nextToReveal turn state
                    round = ShowdownRound
  else
    fmap AwaitingDealer $ create DealerTurn with state

afterBet : Party -> RoundState -> Update Next
afterBet turn state = 
    if all (maximum state.bets ==) (activeBets state) then
        finishRound turn state
    else
        fmap AwaitingPlayer $ 
            create PlayerTurn with 
                state
                turn = nextActivePlayer turn state
                round = BettingRound

afterCheck : Party -> RoundState -> Update Next
afterCheck turn state = 
    if turn == lastCheck state then
        finishRound turn state
    else
        fmap AwaitingPlayer $ 
            create PlayerTurn with 
                state
                turn = nextActivePlayer turn state
                round = CheckRound

template PlayerTurn
    with
        state : RoundState
        round : Round
        turn : Party
    where
        signatory state.table.players

        choice Reveal : Next
            with
                player : Party
            controller player
            do
                assert $ elem player $ state.table.players
                
                let index = indexOf player state.table.players

                case state.revealed !! index of
                    Right handId ->
                        do
                            hand <- fetch handId

                            assert $ hand.dealer == state.table.dealer

                            let revealed = setAt index (Left (hand.card1, hand.card2)) state.revealed
                            let h = this with state = state with revealed

                            if round == ShowdownRound then
                                if toReveal h.state == [] then
                                    fmap HandFinished $ finish h.state
                                else if turn == player then
                                    fmap AwaitingPlayer $ create h with turn = nextToReveal turn state
                                else 
                                    fmap AwaitingPlayer $ create h 
                            else
                                fmap AwaitingPlayer $ create h
                    Left _ ->
                        error "Hand has already been revealed"
 
        choice Fold : Next
            with
                player : Party
            controller player
            do 
                assert $ not $ elem player state.folded
                -- assertMsg ("Player: " <> show player <> " cannot fold as they are currently all in")
                --     $ isSome $ currentStack player state

                pot <- exercise state.pot Leave with leaver = player

                let folded = player :: state.folded

                state <- return $ state with folded, pot

                case inPlay state of
                    [winner] -> 
                        do
                            let index = indexOf winner state.table.players

                            stacks <- updateAtA index (\s -> case s of 
                                                                Some s -> fmap Some $ exercise s Merge with chips = pot, chipsOwners = [player]
                                                                None -> return $ Some pot
                                                                ) state.stacks

                            f <- create Finished with
                                    table = state.table
                                    folded = state.folded
                                    community = state.community
                                    unturned = state.unturned
                                    revealed = state.revealed
                                    stacks
                                    
                            return $ HandFinished f
                    _ -> 
                        if turn == player then
                            case round of
                                CheckRound ->
                                    afterCheck turn state
                                BettingRound ->
                                    afterBet turn state
                                ShowdownRound ->
                                    if toReveal state == [] then
                                        fmap HandFinished $ finish state
                                    else
                                        fmap AwaitingPlayer $ create this with state with
                                            turn = nextToReveal turn state
                        else
                            -- outOfTurnFold $ 
                            error "TODO"

        controller turn can
            Check : Next
                do
                    assertMsg ("Can only check in a check round, current round is: " <> show round) $ round == CheckRound                    
                    afterCheck turn state

            Call : Next
                do
                    assertMsg ("Can only call in a betting round, current round is: " <> show round) $ round == BettingRound

                    state <- placeRequiredAnd 0 turn state
                    afterBet turn state

            Raise : Next
                with
                    amount : Int
                do
                    assert $ round == CheckRound || round == BettingRound           
                    assert $ amount > 0

                    state <- placeRequiredAnd amount turn state
                    afterBet turn state

            AllIn : Next
                do
                    assertMsg ("Can only go all-in, on betting round, current round: " <> show round) $ round == BettingRound

                    let index = indexOf turn state.table.players

                    case state.stacks !! index of
                        Some stack ->
                            do
                                let required = maximum state.bets - state.bets !! index
                                amount <- fmap (.quantity) $ fetch stack

                                state <- placeBet amount turn state
                                afterBet turn state
                        None ->
                            error $ "Player: " <> show turn <> "Cannot go all-in as they have no chips left"        
