daml 1.2

module Rounds where

import Chips
import Seat (Hand (..), PlayerSeed (..))
import Table ()
import Cards
import Utils
import Random (shuffle)
import RoundState

import SidePot (createSidePots1)

import DA.Action (foldlA)
import DA.Optional (mapOptional, isSome, catOptionals)
import DA.List (head, tail, (!!))
import DA.Foldable (maximum)
import DA.Either (partitionEithers)

getSeed : PendingHand -> Update Int
getSeed pending = 
    do
        assert $ all isSome pending.seeds

        seeds <- mapA fetch $ catOptionals pending.seeds 

        assert $ map (.player) seeds == pending.table.players

        return $ sum $ map (.seed) seeds

startGame : ContractId PendingHand -> Update (ContractId BettingRound)
startGame pending = 
    do  
        p <- fetch pending
        seed <- getSeed p

        let shuffled = shuffle seed deck

        let dealer = p.table.dealer
        let n = length p.table.players

        hands <- dealPlayerCards shuffled dealer p.table.players
        
        community <- mapA (\card -> create CommunityCard with dealer, card) $ 
            take 5 $ drop (n * 2) shuffled

        exercise pending StartGame with hands, community 

createPending : Party -> Party -> Int -> ContractId Chips -> Update (ContractId PendingHand)
createPending dealer player smallBlind stack =
    do
        create PendingHand with
            table = Table with
                        dealer
                        players = [player]
                        smallBlind
                        invited = []
            stacks = [stack]
            seeds = [None]

playerReady : Party -> Int -> ContractId PendingHand -> Update (ContractId PendingHand)
playerReady player seed pending =
    do
        dealer <- fmap ((.dealer) . (.table)) $ fetch pending

        seed <- create PlayerSeed with player, dealer, seed

        exercise pending PlayerReady with player, seed

template PendingHand
    with
        table : Table
        stacks : [ContractId Chips]
        seeds : [Optional (ContractId PlayerSeed)]
    where
        signatory table.players
        observer table.invited

        choice InvitePlayer : ContractId PendingHand
            with
                player : Party
                inviter : Party
            controller inviter
            do
                assertMsg ("Inviter: " <> show inviter <> " is not currently a member of table, current members: " <> show table.players)
                    $ elem inviter table.players

                assert $ not $ elem player table.players
                
                stacks <- sequence $ 
                            zipWith (\p s -> exercise s AddObserver with adder = p, obs = player)
                                table.players
                                stacks

                create this with 
                    table = table with invited = player :: table.invited
                    stacks

        choice JoinTable : ContractId PendingHand
            with
                player : Party
                stack : ContractId Chips
            controller player
            do
                assert $ elem player table.invited

                stack <- foldlA (\s p -> exercise s AddObserver with adder = player, obs = p) stack table.players

                create this with
                    table = table with players = player :: table.players
                    stacks = stack :: stacks
                    seeds = None :: seeds

        choice LeaveTable : ContractId PendingHand
            with
                player : Party
            controller player
            do
                assert $ elem player table.players

                let index = indexOf player table.players

                create this with
                    table = table with players = deleteAt index table.players
                    seeds = deleteAt index seeds

        choice PlayerReady : ContractId PendingHand
            with
                player : Party
                seed : ContractId PlayerSeed
            controller player
            do
                assert $ elem player table.players

                create this with 
                    seeds = setAt (indexOf player table.players) (Some seed) seeds
        
        controller table.dealer can 
            StartGame : ContractId BettingRound
                with
                    hands : [ContractId Hand]
                    community : [ContractId CommunityCard]
                do
                    let l = length table.players
                    -- assert $ all isSome seeds
                    assert $ l > 1
                    assert $ length community == 5
                    assert $ l == length hands

                    let bigBlind = table.smallBlind * 2

                    (sb, remaining0) <- exercise (stacks !! 0) Split with amount = table.smallBlind
                    (bb, remaining1) <- exercise (stacks !! 1) Split with amount = bigBlind

                    pot <- exercise sb Merge with chips = bb, chipsOwners = [table.players !! 1]

                    let bets = table.smallBlind :: bigBlind :: replicate (l - 2) 0
                    let newStacks = map Some $ remaining0 :: remaining1 :: drop 2 stacks

                    create BettingRound
                        with
                            state = RoundState
                                        with
                                            table
                                            stacks = newStacks
                                            bets
                                            folded = []
                                            pot
                                            unturned = community
                                            community = []
                                            revealed = map Right hands

                            turn = table.players !! (l % 3)

optionalOnSnd : (a, Optional b) -> Optional (a, b)
optionalOnSnd (a, Some b) = Some (a, b)
optionalOnSnd (a, None) = None

template Finished
    with 
       table : Table
       folded : [Party]
       stacks : [Optional (ContractId Chips)]
       unturned : [ContractId CommunityCard]
       community : [Card]
       revealed : [Either (Card, Card) (ContractId Hand)]
    where
        signatory table.players

        choice NextHand : ContractId PendingHand
            controller table.players
            do
                let (p, s) = unzip $ mapOptional optionalOnSnd $ zip table.players stacks

                create PendingHand with
                    table = table with players = rotate p
                    stacks = rotate s
                    seeds = replicate (length p) None

        choice ShowHand : ContractId Finished
            with
                player : Party
            controller player
            do
                -- state <- reveal player state

                -- ssert $ elem player $ table.players
                
                -- let index = indexOf player table.players

                -- hand <- fetch $ state.handIds !! index

                -- assert $ hand.dealer == state.table.dealer

                -- let revealed = setAt index (Right (hand.card1, hand.card2)) state.revealed

                error "TODO"
            
template DealerTurn
    with
        state : RoundState
    where
        signatory state.table.players

        controller state.table.dealer can 
            TurnCommunity : Either (ContractId CheckRound) (ContractId ShowdownRound)
                do
                    assert $ state.unturned /= []

                    (turned, unturned) <- 
                                if length (activePlayers state) < 2 then
                                    do  
                                        cards <- mapA (fmap (.card) . fetch) state.unturned               
                                        return $ (cards, [])                                        
                                else if length state.community == 0 then
                                    do
                                        cards <- mapA (fmap (.card) . fetch) $ take 3 state.unturned
                                        return $ (cards, drop 3 state.unturned)
                                else
                                    do
                                        card <- fmap (.card) $ fetch $ head state.unturned
                                        return $ ([card], tail state.unturned)

                    let community = state.community ++ turned

                    if length (activePlayers state) < 2 then
                        do
                            fmap Right $
                                create ShowdownRound with
                                    state = state with community, unturned
                                    turn = head $ toReveal state
                    else
                        do
                            fmap Left $
                                create CheckRound with
                                    state = state with community, unturned
                                    turn = head $ activePlayers state

mergeChips : Party -> Optional (ContractId Chips) -> Optional (ContractId Chips) -> Update (Optional (ContractId Chips))
mergeChips owner a b =
        case (a, b) of
            (None, None) -> return None
            (Some a, None) -> return $ Some a
            (None, Some b) -> return $ Some b
            (Some a, Some b) ->
                do
                    chips <- exercise a Merge with chips = b, chipsOwners = [owner]
                    return $ Some chips

finish : RoundState -> Update (ContractId Finished)
finish state =
    do
        let (unfolded, folded) = 
                partitionEithers $
                    zipWith3 (\player bet revealed ->
                                case revealed of
                                    Left r -> Left (player, bet, r)
                                    Right _ -> Right bet)
                        state.table.players
                        state.bets
                        state.revealed

        let pots = createSidePots1 state.community folded unfolded

        let allocation = concatMap allocate pots

        shares <- splitPot state.pot allocation

        stacks <- sequence $ 
                    zipWith (\player stack ->
                                do
                                    let share = fmap snd $ find ((player ==) . fst) shares
                                    mergeChips player share stack)
                    
                        state.table.players
                        state.stacks

        create Finished with
            table = state.table
            folded = state.folded
            stacks
            unturned = state.unturned
            community = state.community
            revealed = state.revealed
  
type RoundEnd = Either (ContractId DealerTurn) (ContractId ShowdownRound)

template ShowdownRound
    with
        state : RoundState
        turn : Party
    where
        signatory state.table.players

        choice ShowdownRound_Reveal : Either (ContractId ShowdownRound) (ContractId Finished)
            with
                player : Party
            controller player
            do
                state <- reveal player state
                
                if toReveal state == [] then
                    fmap Right $ finish state
                else if turn == player then
                    fmap Left $ create this with 
                                    turn = nextToReveal turn state
                                    state
                else 
                    fmap Left $ create this with state

        choice ShowdownRound_Fold : Either (ContractId ShowdownRound) (ContractId Finished)
            with
                player : Party
            controller player
            do 
                state <- fold player state
                winner <- afterFoldCheckForWinner state
                case winner of
                    Some finished ->
                        return $ Right finished
                    None ->
                        if toReveal state == [] then
                            fmap Right $ finish state
                        else if turn == player then
                            fmap Left $ create this with 
                                state
                                turn = nextToReveal player state
                        else 
                            fmap Left $ create this with state

type Next a = Either (ContractId a) RoundEnd
type FoldNext a = Either (Next a) (ContractId Finished)

afterFoldCheckForWinner : RoundState -> Update (Optional (ContractId Finished))
afterFoldCheckForWinner state = 
    do
        case inPlay state of
            [winner] -> 
                do
                    let index = indexOf winner state.table.players

                    stacks <- updateAtA index (\s -> case s of 
                                                        Some s -> fmap Some $ exercise s Merge with chips = state.pot, chipsOwners = [winner]
                                                        None -> return $ Some state.pot
                                                        ) state.stacks

                    f <- create Finished with
                            table = state.table
                            folded = state.folded
                            community = state.community
                            unturned = state.unturned
                            revealed = state.revealed
                            stacks

                    return $ Some f
            _ -> return None

check : Party -> RoundState -> Update (Next CheckRound)
check turn state = 
    do
        if turn == lastCheck state then
            fmap Right $ finishRound turn state
        else
            fmap Left $ 
                create CheckRound with 
                    state
                    turn = nextActivePlayer turn state

template CheckRound
    with 
        state : RoundState
        turn : Party
    where
        signatory state.table.players

        choice CheckRound_Reveal : ContractId CheckRound
            with
                player : Party
            controller player
            do
                state <- reveal player state
                create this with state

        choice CheckRound_Fold : FoldNext CheckRound
            with
                player : Party
            controller player
            do
                state <- fold player state
                winner <- afterFoldCheckForWinner state
                case winner of
                    Some finished ->
                        return $ Right finished
                    None | turn == player ->
                        fmap Left $ check turn state
                    None ->
                        -- outOfTurnFold $ 
                        error "TODO"

        controller turn can
            CheckRound_Check : Next CheckRound
                do check turn state

            CheckRound_Raise : ContractId BettingRound
                with
                    amount : Int
                do
                    assert $ amount > 0

                    state <- placeBet (Some amount) turn state
                    create BettingRound with
                        state
                        turn = nextActivePlayer turn state

finishRound : Party -> RoundState -> Update RoundEnd
finishRound turn state = 
  if length state.community == 5 then
    do
        showdown <- create ShowdownRound with 
            state
            turn = nextToReveal turn state

        return $ Right showdown
  else
    fmap Left $ create DealerTurn with state

afterBet : Party -> RoundState -> Update (Next BettingRound)
afterBet turn state = 
    if all (maximum state.bets ==) (activeBets state) then
        fmap Right $ finishRound turn state
    else
        fmap Left $ 
            create BettingRound with 
                state
                turn = nextActivePlayer turn state

template BettingRound
    with 
        state : RoundState
        turn : Party
    where
        signatory state.table.players

        choice BettingRound_Fold : FoldNext BettingRound
            with
                player : Party
            controller player
            do
                state <- fold player state
                winner <- afterFoldCheckForWinner state
                case winner of
                    Some finished ->
                        return $ Right finished
                    None | turn == player ->
                        fmap Left $ afterBet turn state
                    None ->
                        -- outOfTurnFold $ 
                        error "TODO"

        choice BettingRound_Reveal : ContractId BettingRound
            with
                player : Party
            controller player
            do
                state <- reveal player state
                create this with state

        controller turn can
            BettingRound_Call : Next BettingRound
                do
                    state <- placeRequiredAnd 0 turn state
                    afterBet turn state

            BettingRound_Raise : Next BettingRound
                with
                    amount : Int
                do
                    assert $ amount > 0
                    state <- placeRequiredAnd amount turn state
                    afterBet turn state

            BettingRound_AllIn : Next BettingRound
                do
                    state <- placeBet None turn state                 
                    afterBet turn state       
