daml 1.2

module Seat where

import Cards
import DA.Optional
import DA.List
import DA.Foldable (maximum)

data Seat = Seat with
    folded : Bool
    holeCards : Optional (Card, Card)
    player : Party
    bet : Int
    stack : Int
        deriving (Eq, Show)

playerSeat : Party -> [Seat] -> Seat
playerSeat player seats =
    fromSome $ find (\s -> s.player == player) seats

active : Seat -> Bool
active seat = seat.stack > 0 && not seat.folded

nextActivePlayer : Party -> [Seat] -> Party
nextActivePlayer player seats = 
    (.player) $
    head $
    filter active $
    tail $
    dropWhile (\s -> s.player /= player) $ 
    seats ++ seats

nextPlayer : Party -> [Seat] -> Party
nextPlayer player seats = 
    (.player) $
    head $
    filter (not . (.folded)) $
    tail $
    dropWhile (\s -> s.player /= player) $ 
    seats ++ seats

biggestBet : [Seat] -> Int
biggestBet = maximum . map (.bet)

requiredBet : Party -> [Seat] -> Int
requiredBet player seats = 
    biggestBet seats - ((.bet) $ playerSeat player seats)

activeBets : [Seat] -> [Int]
activeBets = map (.bet) . filter active

remaining : Seat -> Int
remaining seat = seat.stack - seat.bet

updateSeat : Party -> (Seat -> Seat) -> [Seat] -> [Seat]
updateSeat player f = 
    map (\s -> if s.player == player then f s else s)

placeBet : Int -> Party -> [Seat] -> Update [Seat]
placeBet amount player seats =
    do
        assert $ remaining seat >= required

        return $ updateSeat player (\s -> s with bet = s.bet + required) seats
    where
        seat = findSeat player seats
        required = amount + requiredBet player seats

call : Party -> [Seat] -> Update [Seat]
call player seats = do placeBet 0 player seats

raise : Int -> Party -> [Seat] -> Update [Seat]
raise amount player seats = do placeBet amount player seats

fold : Party -> [Seat] -> [Seat]
fold player = updateSeat player (\s -> s with folded = True, stack = s.bet)

allIn : Party -> [Seat] -> [Seat]
allIn player = updateSeat player (\s -> s with bet = s.stack)

pot : [Seat] -> Int
pot = sum . map (.bet)

reveal : Party -> (Card, Card) -> [Seat] -> [Seat]
reveal player hand = 
    updateSeat player (\s -> s with holeCards = Some hand)
    
-- returnRemaining : [Seat] -> [Seat]
-- returnRemaining = map (\s -> s with stack = s.bet)

findSeat : Party -> [Seat] -> Seat
findSeat player = fromSome . find (\s -> player == s.player)

inGame : [Seat] -> [Party]
inGame = map (.player) . filter (not . (.folded))

loopAfter : (a -> Bool) -> [a] -> [a]
loopAfter f xs = 
    begin ++ (x :: end) where (end, x :: begin) = break f xs

afterPlayer : Party -> [Seat] -> [Seat]
afterPlayer player = loopAfter (\s -> s.player == player)

nextInGame : Party -> [Seat] -> Party
nextInGame player =
    (.player) . fromSome . find (not . (.folded)) . afterPlayer player

activePlayers : [Seat] -> [Party]
activePlayers = map (.player) . filter (\s -> not s.folded && s.stack > s.bet)
