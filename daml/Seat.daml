daml 1.2

module Seat where

import Cards
import DA.Optional
import DA.List
import DA.Foldable (maximum)

template PlayerSeed 
    with
        player : Party
        dealer : Party
        seed : Int
    where
        signatory player 
        observer dealer

template Hand
    with
        holder : Party
        dealer : Party
        -- id : Int
        -- k : ContractId GameKey
        card1 : Card
        card2 : Card
        obs : [Party]
    where
        signatory dealer
        observer obs
        
        controller holder can 
            RevealHand : ContractId Hand
                with
                    to : [Party]
                do
                    create this with obs = to
                    
        -- key (id, holder, dealer) : (Int, Party, Party)

        -- maintainer key._3

data Revealed =
    NotDealt | 
    HiddenHand (ContractId Hand) |
    HoleCards (Card, Card) deriving (Eq, Show)

data Seat = Seat with
    seed : ContractId PlayerSeed
    folded : Bool
    revealed : Revealed
    -- holeCards : Optional (Card, Card)
    player : Party
    bet : Int
    stack : Int
        deriving (Eq, Show)

playerSeat : Party -> [Seat] -> Seat
playerSeat player seats =
    fromSome $ find (\s -> s.player == player) seats

active : Seat -> Bool
active seat = seat.stack > seat.bet && not seat.folded

nextActivePlayer : Party -> [Seat] -> Party
nextActivePlayer player seats = 
    (.player) $
    head $
    filter active $
    tail $
    dropWhile (\s -> s.player /= player) $ 
    seats ++ seats

nextPlayer : Party -> [Seat] -> Party
nextPlayer player seats = 
    (.player) $
    head $
    filter (not . (.folded)) $
    tail $
    dropWhile (\s -> s.player /= player) $ 
    seats ++ seats

biggestBet : [Seat] -> Int
biggestBet = maximum . map (.bet)

requiredBet : Party -> [Seat] -> Int
requiredBet player seats = 
    biggestBet seats - ((.bet) $ playerSeat player seats)

activeBets : [Seat] -> [Int]
activeBets = map (.bet) . filter active

remaining : Seat -> Int
remaining seat = seat.stack - seat.bet

updateSeat : Party -> (Seat -> Seat) -> [Seat] -> [Seat]
updateSeat player f = 
    map (\s -> if s.player == player then f s else s)

placeBet : Int -> Party -> [Seat] -> Update [Seat]
placeBet amount player seats =
    do
        let msg = "Not enough funds for: " <> show player <> " to place bet"
        assertMsg msg $ remaining seat >= required

        return $ updateSeat player (\s -> s with bet = s.bet + required) seats
    where
        seat = findSeat player seats
        required = amount + requiredBet player seats

call : Party -> [Seat] -> Update [Seat]
call player seats = do placeBet 0 player seats

raise : Int -> Party -> [Seat] -> Update [Seat]
raise amount player seats = do placeBet amount player seats

fold : Party -> [Seat] -> [Seat]
fold player = updateSeat player (\s -> s with folded = True, stack = s.bet)

allIn : Party -> [Seat] -> [Seat]
allIn player = updateSeat player (\s -> s with bet = s.stack)

pot : [Seat] -> Int
pot = sum . map (.bet)

reveal : Party -> (Card, Card) -> [Seat] -> [Seat]
reveal player hand = 
    updateSeat player (\s -> s with revealed = HoleCards hand)
    
-- returnRemaining : [Seat] -> [Seat]
-- returnRemaining = map (\s -> s with stack = s.bet)

findSeat : Party -> [Seat] -> Seat
findSeat player = fromSome . find (\s -> player == s.player)

inGame : [Seat] -> [Party]
inGame = map (.player) . filter (not . (.folded))

loopAfter : (a -> Bool) -> [a] -> [a]
loopAfter f xs = 
    begin ++ (x :: end) where (end, x :: begin) = break f xs

afterPlayer : Party -> [Seat] -> [Seat]
afterPlayer player = loopAfter (\s -> s.player == player)

nextInGame : Party -> [Seat] -> Party
nextInGame player =
    (.player) . fromSome . find (not . (.folded)) . afterPlayer player

activePlayers : [Seat] -> [Party]
activePlayers = map (.player) . filter (\s -> not s.folded && s.stack > s.bet)
