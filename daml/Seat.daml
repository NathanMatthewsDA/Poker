daml 1.2

module Seat where

import Cards
import Chips
import Utils
import DA.List (head, delete)
import DA.Optional (fromSome, mapOptional)
import SidePot (SidePot, createSidePots1)
import DA.Action (foldlA)

template HiddenSeed
    with
        dealer : Party
        player : Party
        seed : Int
    where
        signatory player
        observer dealer

template HiddenHand
    with
        holder : Party
        dealer : Party
        card1 : Card
        card2 : Card
    where
        signatory dealer
        observer holder

data Stack = 
    Folded (ContractId Chips) | 
    InPlay (ContractId Chips) |
    AllIn 
    deriving (Eq, Show)

data Hand = 
    Hidden (ContractId HiddenHand) |
    Revealed (Card, Card) |
    AwaitingHand
    -- AwaitingSeed |
    -- AwaitingHand (ContractId HiddenSeed)
    deriving (Eq, Show)

data Seat = Seat with
        player : Party
        hand : Hand
        stake : Int
        stack : Stack
    deriving (Eq, Show)

isFolded : Stack -> Bool
isFolded (Folded _) = True
isFolded _ = False

isInPlay : Stack -> Bool
isInPlay (InPlay _) = True
isInPlay _ = False

avaliable : Stack -> Update Int
avaliable (Folded chips) = fmap (.quantity) $ fetch chips
avaliable (InPlay chips) = fmap (.quantity) $ fetch chips
avaliable AllIn = return 0

playersWithAtLeast : Int -> [Seat] -> Update [Party]
playersWithAtLeast amount seats =
    do
        a <- mapA (avaliable . (.stack)) seats
        return $ map fst $ filter ((amount <=) . snd) $ zip (map (.player) seats) a

-- https://en.wikipedia.org/wiki/Glossary_of_poker_terms
-- active player
-- A player still involved in the pot. If there are side pots, 
-- an all-in player may be active in some pots, but not in others.

filterActive : [Seat] -> [Seat]
filterActive = filter (not . isFolded . (.stack))

activePlayers : [Seat] -> [Party]
activePlayers = map (.player) . filterActive

seatsAfter : Party -> [Seat] -> [Seat]
seatsAfter player seats = after ((findSeat player seats) ==) seats

filterInPlay : [Seat] -> [Seat]
filterInPlay = filter (isInPlay . (.stack))

nextInPlay : [Seat] -> Party
nextInPlay = (.player) . head . filterInPlay

nextToBet : Party -> [Seat] -> Party
nextToBet lastPlayer = nextInPlay . seatsAfter lastPlayer 

toBet : [Seat] -> [Party]
toBet = map (.player) . filter (isInPlay . (.stack))

isRevealed : Hand -> Bool
isRevealed (Revealed _) = True
isRevealed _ = False

nextToReveal : Party -> [Seat] -> Optional Party
nextToReveal lastPlayer seats =
    fmap (.player) $ find (isRevealed . (.hand)) $ seatsAfter lastPlayer seats

findSeat : Party -> [Seat] -> Seat
findSeat player = fromSome . find ((player ==) . (.player))

toSidePots : [Card] -> [Seat] -> [SidePot]
toSidePots community seats =
    do
        let foldedStakes = (map (.stake) $ filter (isFolded . (.stack)) seats)
        let hands = mapOptional (\s -> case s.hand of 
                                          Revealed cards -> Some (s.player, s.stake, cards)
                                          _ -> None) $ filterActive seats
        createSidePots1 community foldedStakes hands

resetStack : Stack -> Stack
resetStack (Folded stack) = InPlay stack
resetStack other = other

resetSeat : Seat -> Seat
resetSeat seat = seat with 
                    hand = AwaitingHand
                    stake = 0
                    stack = resetStack seat.stack

addObservers : ContractId Chips -> [Party] -> Update (ContractId Chips)
addObservers = foldlA (\chips player -> exercise chips AddChipsObserver with player)

buyIn : Party -> ContractId Chips -> Int -> [Seat] -> Update [Seat]
buyIn player chips tableStake seats =
    do
        quantity <- fmap (.quantity) $ fetch chips
        
        case find ((player ==) . (.player)) seats of
            Some seat ->   
                case seat.stack of 
                    AllIn -> 
                        do
                            checkQuantity quantity

                            chips <- addObservers chips (delete player (map (.player) seats))

                            let newSeat = seat with stack = InPlay chips

                            return $ replace seat newSeat seats

                    InPlay stack ->
                        do
                            stack <- exercise stack Merge with chips

                            quantity <- fmap (.quantity) $ fetch stack

                            checkQuantity quantity                        

                            let newSeat = seat with stack = InPlay stack 
                            
                            return $ replace seat newSeat seats

                    Folded _ -> error "Illegal state, shouldn't be any folded seats when buying in"

            None ->
                do
                    checkQuantity quantity

                    let newSeat = Seat with player, hand = AwaitingHand, stake = 0, stack = InPlay chips

                    chips <- addObservers chips (map (.player) seats)

                    let newSeat = Seat with player, hand = AwaitingHand, stake = 0, stack = InPlay chips

                    return $ newSeat :: seats
    where
        checkQuantity quantity = 
            assertMsg ("Cannot buy-in as amount: " <> 
                       show quantity <> 
                       " does not meet required table stake: " <> 
                       show tableStake) $ 
                        quantity >= tableStake

mergeWinnings : [(Party, ContractId Chips)] -> Seat -> Update Seat
mergeWinnings winnings seat =
    case find ((seat.player ==) . fst) winnings of
        Some (player, chips) -> 
            case seat.stack of
                Folded _ ->
                    error ("Illegal State: Folded player: " 
                            <> show player <> 
                            " should not have winnings: " <> show chips)
                
                InPlay stack ->
                    do
                        chips <- exercise stack Merge with chips
                        return $ seat with stack = InPlay chips    
                AllIn ->
                    return $ seat with stack = InPlay chips
        None ->
            return seat

addStackObserver : Stack -> Party -> Update Stack
addStackObserver AllIn _ = return AllIn
addStackObserver (Folded chips) player = 
    fmap Folded $ exercise chips AddChipsObserver with player
addStackObserver (InPlay chips) player = 
    fmap InPlay $ exercise chips AddChipsObserver with player

