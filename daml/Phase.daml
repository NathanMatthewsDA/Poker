daml 1.2

module Phase where

import Cards
import Seat
import Utils
import DA.Optional
import DA.List
import SidePot

data Round = CheckRound | BettingRound | ShowdownRound deriving (Eq, Show)

data EndGame = 
    OneRemaining (Party, Int) | 
    ShowdownWinners [SidePot]
        deriving (Eq, Show)

data Phase =
    DealerTurn |
    PlayerTurn (Party, Round) |
    Finished EndGame
        deriving (Eq, Show)

roundType : Phase -> Round
roundType (PlayerTurn (_, round)) = round
roundType DealerTurn = error ""
roundType (Finished _) = error ""

inTurn : Party -> Phase -> Bool
inTurn _ DealerTurn = False
inTurn _ (Finished _) = False
inTurn player (PlayerTurn (turn, _)) = player == turn

nextPhase : [Card] -> [Seat] -> Phase -> Phase
nextPhase community seats phase = 
    case phase of
        Finished _ -> error "TODO"

        DealerTurn | length community < 3 ->
            DealerTurn
            -- PlayerTurn (firstActive, CheckRound) 

        -- DealerTurn | length activeSeats < 2 && communityFull -> 
        --     PlayerTurn (firstActive, ShowdownRound)

        -- DealerTurn | length activeSeats < 2 -> 
        --     DealerTurn

        DealerTurn ->
            PlayerTurn ((.player) $ head activeSeats, CheckRound) 
        
        PlayerTurn (current, round) ->
            case round of
                CheckRound | not betsEqual ->
                    PlayerTurn (nextActivePlayer current seats, BettingRound)
                
                CheckRound | isLastActive current && communityFull ->
                    PlayerTurn (nextNonFolded, ShowdownRound)

                CheckRound | isLastActive current ->
                    DealerTurn

                CheckRound ->
                    PlayerTurn (nextActivePlayer current seats, CheckRound)

                BettingRound | betsEqual && communityFull -> 
                    PlayerTurn (nextNonFolded, ShowdownRound)

                BettingRound | betsEqual -> 
                    DealerTurn

                BettingRound ->
                    PlayerTurn (nextActivePlayer current seats, BettingRound)

                ShowdownRound ->
                    PlayerTurn (nextNonFolded, ShowdownRound)
                
            where
                --lastActive = (.player) $ last activeSeats
                nextNonFolded = nextPlayer current seats
                -- nextActive = nextActivePlayer current seats

    where
        isLastActive player = player == ((.player) $ last activeSeats)
        activeSeats = filter active seats
        --firstActive = (.player) $ head activeSeats
        betsEqual = allEqual $ map (.bet) $ activeSeats
        communityFull = length community == 5
