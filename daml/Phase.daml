daml 1.2

module Phase where

import Cards
import Seat
import Utils
import DA.List
import SidePot

data Round = CheckRound | BettingRound | ShowdownRound deriving (Eq, Show)

data EndGame = 
    OneRemaining (Party, Int) | 
    ShowdownWinners [SidePot]
        deriving (Eq, Show)

data Turn = DealerTurn | PlayerTurn (Party, Round) deriving (Eq, Show)

data Phase =
    WaitingForPlayers with
        pendingJoin : [Party]
        pendingReady : [Party] |
    InGame Turn |
    -- DealerTurn |
    -- PlayerTurn (Party, Round) |
    Finished EndGame
        deriving (Eq, Show)

roundType : Phase -> Round
roundType (InGame (PlayerTurn (_, round))) = round
roundType (Finished _) = error "No round type, game has finished"
roundType (WaitingForPlayers {}) = error "No round type, game hasnt started"

inTurn : Party -> Phase -> Bool
inTurn player (InGame (PlayerTurn (turn, _))) = player == turn
inTurn _ _ = False

nextPhase : [Card] -> [Seat] -> Phase -> Phase
nextPhase community seats phase = 
    case phase of
        Finished _ -> WaitingForPlayers {pendingReady = map (.player) seats, pendingJoin = []}
        
        -- WaitingForPlayers {pendingReady = []} -> InGame $ PlayerTurn ((head seats).player, BettingRound)

        w@(WaitingForPlayers _ _) -> w

        InGame (DealerTurn) | length community < 3 -> InGame (DealerTurn)
            -- PlayerTurn (firstActive, CheckRound) 

        -- DealerTurn | length activeSeats < 2 && communityFull -> 
        --     PlayerTurn (firstActive, ShowdownRound)

        -- DealerTurn | length activeSeats < 2 -> 
        --     DealerTurn

        InGame (DealerTurn) ->
            InGame (PlayerTurn ((.player) $ head activeSeats, CheckRound))
        
        InGame (PlayerTurn (current, round)) ->
            InGame (case round of
                CheckRound | not betsEqual ->
                    PlayerTurn (nextActivePlayer current seats, BettingRound)
                
                CheckRound | isLastActive current && communityFull ->
                    PlayerTurn (nextNonFolded, ShowdownRound)

                CheckRound | isLastActive current ->
                    DealerTurn

                CheckRound ->
                    PlayerTurn (nextActivePlayer current seats, CheckRound)

                BettingRound | betsEqual && communityFull -> 
                    PlayerTurn (nextNonFolded, ShowdownRound)

                BettingRound | betsEqual -> 
                    DealerTurn

                BettingRound ->
                    PlayerTurn (nextActivePlayer current seats, BettingRound)

                ShowdownRound ->
                    PlayerTurn (nextNonFolded, ShowdownRound))
                
            where
                --lastActive = (.player) $ last activeSeats
                nextNonFolded = nextPlayer current seats
                -- nextActive = nextActivePlayer current seats

    where
        isLastActive player = player == ((.player) $ last activeSeats)
        activeSeats = filter active seats
        --firstActive = (.player) $ head activeSeats
        betsEqual = allEqual $ map (.bet) $ activeSeats
        communityFull = length community == 5
