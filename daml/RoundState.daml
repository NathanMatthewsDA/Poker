daml 1.2

module RoundState where

import Chips
import Cards
import Seat (Hand (..), PlayerSeed (..))
import SidePot (createSidePots1, SidePot)

import DA.Action (foldlA)
import DA.Optional (mapOptional, isSome, isNone, catOptionals, fromOptional)
import DA.List (head, tail, (!!), last)
import DA.Foldable (maximum)
import DA.Either (isLeft, isRight, partitionEithers)

import Utils

template CommunityCard
    with
        dealer : Party
        card : Card
    where
        signatory dealer

data Table = Table
    with
        dealer : Party
        players : [Party]
        smallBlind : Int
        invited : [Party]
    deriving (Eq, Show)

data RoundState = RoundState
    with
        table : Table
        stacks : [Optional (ContractId Chips)]
        bets : [Int]
        folded : [Party]
        pot : ContractId Chips
        unturned : [ContractId CommunityCard]
        community : [Card]
        revealed : [Either (Card, Card) (ContractId Hand)]
    deriving (Eq, Show)

split : Int -> Int -> [Int]
split num dem = 
  replicate r (d + 1) ++ replicate (dem - r) d
  where
    d = num / dem
    r = num % dem

allocate : SidePot -> [(Party, Int)]
allocate pot = zip pot.winners $ split pot.pot (length pot.winners) 

splitPot : ContractId Chips -> [(Party, Int)] -> Update [(Party, ContractId Chips)]

splitPot pot [] = error ""
splitPot pot [(player, cut)] =
    do
        p <- fetch pot
        assert $ p.quantity == cut
        pot <- exercise pot TakeOwnership with owner = player
        return [(player, pot)]

splitPot pot ((player, cut) :: cuts) =        
    do
        (forPlayer, pot) <- exercise pot Split with amount = cut
        forPlayer <- exercise forPlayer TakeOwnership with owner = player
        remaining <- splitPot pot cuts
        return $ (player, forPlayer) :: remaining

placeBet : Optional Int -> Party -> RoundState -> Update RoundState
placeBet amount player state =
    case state.stacks !! index of
        Some stack ->
            do
                s <- fetch stack

                let a = fromOptional s.quantity amount

                assertMsg ("Stack quantity: " <> show s.quantity <> 
                            " for player: " <> show player <> 
                            " is not enough for placed bet: " 
                                <> show a) $ s.quantity >= a

                (toAdd, remaining) <- if s.quantity == a then
                                            do return (stack, None)
                                        else
                                            do
                                               (toAdd, remaining) <- 
                                                exercise stack Split with amount = a
                                               return (toAdd, Some remaining)

                pot <- exercise state.pot Merge with 
                                    chips = toAdd
                                    chipsOwners = [player]

                return $ state with pot
                                    stacks = setAt index remaining state.stacks
                                    bets = updateAt index (a +) state.bets
        None ->
            error $ "Cannot place bet of: " <> show amount <> " for player: " <>
                        show player <> " as there is no table stack left"
    where
        index = indexOf player state.table.players

placeRequiredAnd : Int -> Party -> RoundState -> Update RoundState
placeRequiredAnd amount player state =
    placeBet (Some (amount + required)) player state
    where
        index = indexOf player state.table.players
        required = maximum state.bets - state.bets !! index
 
lastCheck : RoundState -> Party
lastCheck = last . activePlayers

nextTurn : Party -> RoundState -> Party
nextTurn player state = findNext player $ inPlay state

inPlay : RoundState -> [Party]
inPlay state = filter (\p -> not (elem p state.folded)) state.table.players

activePlayers : RoundState -> [Party]
activePlayers state = 
    map fst $
    filter (\(player, stack) -> isSome stack && not (elem player state.folded)) $
    zip state.table.players state.stacks
    
findNext : (Eq a) => a -> [a] -> a
findNext x xs = head $ tail $ dropWhile (x /=) $ xs ++ xs

startingAfter : (a -> Bool) -> [a] -> [a]
startingAfter p xs = e ++ s ++ [x] where (s, (x :: e)) = break p xs
        
currentStack : Party -> RoundState -> Optional (ContractId Chips)
currentStack player state = 
    state.stacks !! indexOf player state.table.players

active : Party -> RoundState -> Bool
active player state = 
    not (elem player state.folded) && isSome (currentStack player state)

nextActivePlayer : Party -> RoundState -> Party
nextActivePlayer player state = 
    head $ filter (\p -> active p state) $ startingAfter (player ==) state.table.players

currentRevealed : Party -> RoundState -> Either (Card, Card) (ContractId Hand)
currentRevealed player state = 
    state.revealed !! indexOf player state.table.players

requireReveal : Party -> RoundState -> Bool
requireReveal player state = 
    not (elem player state.folded) && isRight (currentRevealed player state)

nextToReveal : Party -> RoundState -> Party
nextToReveal player state = 
    head $ filter (\p -> requireReveal p state) $ startingAfter (player ==) state.table.players

toReveal : RoundState -> [Party]
toReveal state =
    map fst $
    filter (\(player, revealed) -> isRight revealed && not (elem player state.folded)) $
    zip state.table.players state.revealed

currentBet : Party -> RoundState -> Int
currentBet player state = state.bets !! indexOf player state.table.players

activeBets : RoundState -> [Int]
activeBets state = map (\p -> currentBet p state) $ activePlayers state

fold : Party -> RoundState -> Update RoundState
fold player state = 
    do
        assert $ not $ elem player state.folded
        -- assertMsg ("Player: " <> show player <> " cannot fold as they are currently all in")
        --     $ isSome $ currentStack player state

        pot <- exercise state.pot Leave with leaver = player

        let folded = player :: state.folded

        return $ state with folded, pot


reveal : Party -> RoundState -> Update RoundState
reveal player state =
    do
        assert $ elem player $ state.table.players
        
        let index = indexOf player state.table.players

        case state.revealed !! index of
            Right handId ->
                do
                    hand <- fetch handId

                    assert $ hand.dealer == state.table.dealer

                    let revealed = setAt index (Left (hand.card1, hand.card2)) state.revealed
                    return $ state with revealed
            Left _ ->
                error "Hand has already been revealed"

dealPlayerCards : [Card] -> Party -> [Party] -> Update [ContractId Hand]
dealPlayerCards shuffled dealer players =
    do
        let n = length players
        
        let pairs = zip shuffled (drop n shuffled)

        sequence $ zipWith (\holder (card1, card2) -> 
                                        create Hand with
                                            holder
                                            dealer
                                            card1
                                            card2
                                            obs = [])
                                players
                                pairs
